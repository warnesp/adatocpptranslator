/*****************************************************************************
 *                      Ada_to_C_Cpp_Translator
 *****************************************************************************
 * Adatoccpptranslator is a free software which convert Ada code to C/C++ 
 * source code
 * Copyright (C) 2004 Julien THEVENON
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option) 
 * any later version.
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
 * more details.
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 * For further informations : adatoccpptranslator@free.fr
 * 
 * Description: Syntaxic Analyser of Ada language
 *
 * $Log: syntax.y,v $
 * Revision 1.3  2005/03/19 10:54:02  quicky2000
 * Update to restablish cvs logs
 *
 * Revision 1.1  2005/03/07 23:36:43  quicky2000
 * Update to modify include paths due to to new source organization
 * modification of name of node Node_Ada_And_Com to Node_Ada_C_And_Com
 *
 * Revision 1.1.1.1  2005/03/01 22:20:46  quicky2000
 * Initial import
 *
 *
 *****************************************************************************/

 /******* A YACC grammar for Ada 9X *********************************/
/* Copyright (C) Intermetrics, Inc. 1994 Cambridge, MA  USA        */
/* Copying permitted if accompanied by this statement.             */
/* Derivative works are permitted if accompanied by this statement.*/
/* This grammar is thought to be correct as of May 1, 1994         */
/* but as usual there is *no warranty* to that effect.             */
/*******************************************************************/
%{

#include <stdio.h>
#include <stdlib.h>

#include "../src/Tools/tree.h"
#define YYMAXDEPTH 50000
#define YYINITDEPTH 10000
#define ARBRE

extern int g_LineNumber;
extern char g_BoolSyntaxError;
  
 /*****************************************************************************
 * function name : yylex
 *
 * Input : none
 * Output : integer which is the token return by flex
 * Modified variable : none
 * Description : cf flex documentation
 *****************************************************************************/
int yylex(void);

/*****************************************************************************
 * function name : yyerror
 *
 * Input : reference on a string
 * Output : none
 * Modified variable : none
 * Description : function which display the syntax error return by bison
 *****************************************************************************/
void yyerror(const char* s)
{
  extern char *yytext;
  printf ("\n***** Syntax error : %s on \"%s\" line %i\n",s,yytext,g_LineNumber);
  g_BoolSyntaxError=1;
}

//Preprocessor constant used by Bison to define the return type
#define YYSTYPE tree*

//declaration of yyval
//this variable will contained the tree generated by bison
tree* myYyval;
 

%}

/*---------------------------------------------------------------------
 * Identifier
 *---------------------------------------------------------------------*/
%token  IDF_Lex

/*---------------------------------------------------------------------
 * Quote char
 *---------------------------------------------------------------------*/
%token QUOTECHAR_Lex

/*---------------------------------------------------------------------
 * Constant 
 *---------------------------------------------------------------------*/
// 	   Integer	     Real	    String	Commentary
%token	CONSTENT_Lex	CONSTREEL_Lex	CONSTCHAINE_Lex	COMMENT_Lex

/*---------------------------------------------------------------------
 * reserved words
 *---------------------------------------------------------------------*/
%token	ABORT_Lex	ABS_Lex		ABSTRACT_Lex	ACCEPT_Lex
%token	ACCESS_Lex	ALL_Lex		AND_Lex		ARRAY_Lex
%token	AT_Lex		BEGIN_Lex	BODY_Lex	CASE_Lex
%token	CONSTANT_Lex	DECLARE_Lex	DELAY_Lex	DELTA_Lex
%token	DIGITS_Lex	DO_Lex		ELSE_Lex	ELSIF_Lex
%token	END_Lex		ENTRY_Lex	EXCEPTION_Lex	EXIT_Lex
%token	FOR_Lex		FUNCTION_Lex	GENERIC_Lex	GOTO_Lex
%token	IF_Lex		IN_Lex		IS_Lex		LIMITED_Lex
%token	LOOP_Lex	MOD_Lex		NEW_Lex		NOT_Lex
%token	NULL_Lex	OF_Lex		OR_Lex		OTHERS_Lex
%token	OUT_Lex		PACKAGE_Lex	PRAGMA_Lex	PRIVATE_Lex
%token	PROCEDURE_Lex	RAISE_Lex	RANGE_Lex	RECORD_Lex
%token	REM_Lex		RENAMES_Lex	RETURN_Lex	REVERSE_Lex
%token	SELECT_Lex	SEPARATE_Lex	SUBTYPE_Lex	TASK_Lex
%token	TERMINATE_Lex	THEN_Lex	TYPE_Lex	USE_Lex
%token 	WHEN_Lex	WHILE_Lex	WITH_Lex	XOR_Lex


/* reserved words in Ada95 */
%token	ALIASED_Lex	PROTECTED_Lex	REQUEUE_Lex	TAGGED_Lex
%token	UNTIL_Lex


/*---------------------------------------------------------------------
 * Special symbol
 *---------------------------------------------------------------------*/
// symbol made of only one character are represented by themselves

// special made composed of two characters
//	   ":="           ">="    	  "/="  	    "<="
%token	AFFECT_Lex	SUPEQUAL_Lex	DIFF_Lex	LESSEQUAL_Lex

//	  "**"		   "=>"		  ".."
%token	POWER_Lex	ARROW_Lex	INTER_Lex

//	"<<"		">>"		"<>"
%token LABEL_LEFT_Lex LABEL_RIGHT_Lex BOX_Lex


/*---------------------------------------------------------------------
 * Priority et associativity of operators
 *---------------------------------------------------------------------*/
// operaors placed on the same line have the same priority
// line are sort by increased priority

%nonassoc '<' '>' '=' DIFF_Lex INFEGAL_Lex SUPEGAL_Lex
%left '+' '-' OR_Lex XOR_Lex
%left '*' '/' AND_Lex
%nonassoc POWER_Lex
%nonassoc NOT_Lex

/*---------------------------------------------------------------------
 * Grammar axiom
 *---------------------------------------------------------------------*/
%start program

/*---------------------------------------------------------------------
 * Grammar rules
 *---------------------------------------------------------------------*/
%%


program : compilation
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Program, $1, $1->getNumLine());
  	myYyval = $$;
	
	#endif
	}
	;

pragma  : PRAGMA_Lex IDF_Lex ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Pragma, $2 , $1->getNumLine());
	#endif
	}
	| PRAGMA_Lex simple_name '(' pragma_arg_s ')' ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Pragma, $2 , $4, $1->getNumLine());
	#endif
	}
	;

pragma_arg_s : pragma_arg
	{
	#ifdef ARBRE
	$$ = $1 ;
	#endif
	}
	| pragma_arg_s ',' pragma_arg
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_List_Pragma_Arg, $1 , $3, $1->getNumLine());
	#endif
	}
	;

pragma_arg : expression
	{
	#ifdef ARBRE
	$$ = $1 ;
	#endif
	}
	| simple_name ARROW_Lex expression
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Pragma_Arg, $1, $3, $1->getNumLine());
	#endif
	}
	;

pragma_s :
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	}
	| pragma_s pragma
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_List_Pragma,$1, $2 , $1->getNumLine());
	#endif
	}
	;

decl    : object_decl
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| number_decl
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| type_decl
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| subtype_decl
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| subprog_decl
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| pkg_decl
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| task_decl
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| prot_decl
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| exception_decl
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| rename_decl
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| generic_decl
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| body_stub
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| error ';'
	;

object_decl : def_id_s ':' object_qualifier_opt object_subtype_def init_opt ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Object_Decl,$1,$3,$4,$5,$1->getNumLine());
	#endif
	}
	;

def_id_s : IDF_Lex
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| def_id_s ',' IDF_Lex
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_List_Identifier,$1,$3,$1->getNumLine());
	#endif
	}
	;


object_qualifier_opt :
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	}
	| ALIASED_Lex
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Aliased,$1->getNumLine());
	#endif
	}
	| CONSTANT_Lex
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Constant,$1->getNumLine());
	#endif
	}
	| ALIASED_Lex CONSTANT_Lex
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Aliased_Constant,$1->getNumLine());
	#endif
	}
	;

object_subtype_def : subtype_ind
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| array_type
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	;

init_opt :
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	}
	| AFFECT_Lex expression
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Initialisation_Option,$2,$1->getNumLine());
	#endif
	}
	;

number_decl : def_id_s ':' CONSTANT_Lex AFFECT_Lex expression ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Number_Decl,$1,$5,$1->getNumLine());
	#endif
	}
	;

type_decl : TYPE_Lex IDF_Lex ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Type_Decl,$2,$1->getNumLine());
	#endif
	}
	|
	TYPE_Lex IDF_Lex discrim_part_opt IS_Lex type_def ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Type_Decl,$2,$3,$5,$1->getNumLine());
	#endif
	}
	;

discrim_part_opt :
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	}
	| discrim_part
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| '(' BOX_Lex ')'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Discrim_Part_Opt,$1->getNumLine());
	#endif
	}
	;


type_def : enumeration_type 
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| integer_type
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| real_type
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| array_type
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| record_type
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| access_type
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| derived_type
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| private_type
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	;

subtype_decl : SUBTYPE_Lex IDF_Lex IS_Lex subtype_ind ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Subtype_Decl,$2,$4,$1->getNumLine());
	#endif
	}
	;

subtype_ind : name constraint
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Subtype_Indication,$1,$2,$1->getNumLine());
	#endif
	}
	| name
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Subtype_Indication,$1,$1->getNumLine());
	#endif
	}
	;

constraint : range_constraint
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| decimal_digits_constraint
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	;

decimal_digits_constraint : DIGITS_Lex expression range_constr_opt
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Decimal_Digits_Constraint,$2,$3,$1->getNumLine());
	#endif
	}
	;

derived_type : NEW_Lex subtype_ind
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Derived_Type,$2,$1->getNumLine());
	#endif
	}
	| NEW_Lex subtype_ind WITH_Lex PRIVATE_Lex
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Derived_Type_With_Private,$2,$1->getNumLine());
	#endif
	}
	| NEW_Lex subtype_ind WITH_Lex record_def
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Derived_Type_With_Record,$2,$4,$1->getNumLine());
	#endif
	}
	| ABSTRACT_Lex NEW_Lex subtype_ind WITH_Lex PRIVATE_Lex
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Abstract_Derived_Type_With_Private,$3,$1->getNumLine());
	#endif
	}
	| ABSTRACT_Lex NEW_Lex subtype_ind WITH_Lex record_def
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Abstract_Derived_Type_With_Record,$3,$5,$1->getNumLine());
	#endif
	}
	;

range_constraint : RANGE_Lex range
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Range_Constraint,$2,$1->getNumLine());
	#endif
	}
	;

range : simple_expression INTER_Lex simple_expression
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Range_Inter,$1,$3,$1->getNumLine());
	#endif
	}
	| name '\'' RANGE_Lex
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Range,$1,$1->getNumLine());
	#endif
	}
	| name '\'' RANGE_Lex '(' expression ')'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Range,$1,$5,$1->getNumLine());
	#endif
	}
	;

enumeration_type : '(' enum_id_s ')'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Enumeration_Type,$2,$1->getNumLine());
	#endif
	}
	;

enum_id_s : enum_id
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| enum_id_s ',' enum_id
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_List_Enumeration_Identifier,$1,$3,$1->getNumLine());
	#endif
	}
	;

enum_id : IDF_Lex
	| QUOTECHAR_Lex
	;

integer_type : range_spec
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Integer_Type,$1,$1->getNumLine());
	#endif
	}
	| MOD_Lex expression
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Mod_Integer_Type,$2,$1->getNumLine());
	#endif
	}
	;
	

range_spec : range_constraint
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	;

range_spec_opt :
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	}
	| range_spec
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	;

real_type : float_type
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| fixed_type
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	;

float_type : DIGITS_Lex expression range_spec_opt
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Float_Type,$2,$3,$1->getNumLine());
	#endif
	}
	;

fixed_type : DELTA_Lex expression range_spec
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Fixed_Type,$2,$3,$1->getNumLine());
	#endif
	}
	| DELTA_Lex expression DIGITS_Lex expression range_spec_opt
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Fixed_Type,$2,$4,$5,$1->getNumLine());
	#endif
	}
	;

array_type : unconstr_array_type
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| constr_array_type
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	;

unconstr_array_type : ARRAY_Lex '(' index_s ')' OF_Lex component_subtype_def
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Unconstraint_Array_Type,$3,$6,$1->getNumLine());
	#endif
	}
	;

constr_array_type : ARRAY_Lex '(' iter_discrete_range_s ')' OF_Lex component_subtype_def
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Constraint_Array_Type,$3,$6,$1->getNumLine());
	#endif
	}
	;

component_subtype_def : aliased_opt subtype_ind
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Component_Subtype_Definition,$1,$2,$2->getNumLine());
	#endif
	}
	;

aliased_opt : 
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	}
	| ALIASED_Lex
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Aliased,$1->getNumLine());
	#endif
	}
	;

index_s : index
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| index_s ',' index
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_List_Index,$1,$3,$1->getNumLine());
	#endif
	}
	;

index : name RANGE_Lex BOX_Lex
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Index,$1,$1->getNumLine());
	#endif
	}
	;

iter_discrete_range_s : discrete_range
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| iter_discrete_range_s ',' discrete_range
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_List_Discrete_Range,$1,$3,$1->getNumLine());
	#endif
	}
	;

discrete_range : name range_constr_opt
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Discrete_Range,$1,$2,$1->getNumLine());
	#endif
	}
	| range
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	};

range_constr_opt :
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	}
	| range_constraint
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	;

record_type : tagged_opt limited_opt record_def
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Record_Type,$1,$2,$3,$1->getNumLine());
	#endif
	}
	;

record_def : RECORD_Lex pragma_s comp_list END_Lex RECORD_Lex
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Record_Definition,$2,$3,$1->getNumLine());
	#endif
	}
	| NULL_Lex RECORD_Lex
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Null_Record,$1->getNumLine());
	#endif
	}
	;

tagged_opt :
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	}
	| TAGGED_Lex
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Tagged,$1->getNumLine());
	#endif
	}
	| ABSTRACT_Lex TAGGED_Lex
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Abstract_Tagged,$1->getNumLine());
	#endif
	}
	;

comp_list : comp_decl_s variant_part_opt
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Component_List,$1,$2,$1->getNumLine());
	#endif
	}
	| variant_part pragma_s
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Component_List,$1,$2,$1->getNumLine());
	#endif
	}
	| NULL_Lex ';' pragma_s
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Component_List,$3,$1->getNumLine());
	#endif
	}
	;

comp_decl_s : comp_decl
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| comp_decl_s pragma_s comp_decl
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_List_Component_Decl,$1,$2,$3,$1->getNumLine());
	#endif
	}
	;

variant_part_opt : pragma_s
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| pragma_s variant_part pragma_s
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Variant_Part_Optional,$1,$2,$3,$1->getNumLine());
	#endif
	}
	;

comp_decl : def_id_s ':' component_subtype_def init_opt ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Component_Decl,$1,$3,$4,$1->getNumLine());
	#endif
	}
	| error ';'
	;

discrim_part : '(' discrim_spec_s ')'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Discrim_Part,$2,$1->getNumLine());
	#endif
	}
	;

discrim_spec_s : discrim_spec
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| discrim_spec_s ';' discrim_spec
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_List_Discrim_Spec,$1,$3,$1->getNumLine());
	#endif
	}
	;

discrim_spec : def_id_s ':' access_opt mark init_opt
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Discrim_Spec,$1,$3,$4,$5,$1->getNumLine());
	#endif
	}
	| error
	;

access_opt :
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	}
	| ACCESS_Lex
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Access,$1->getNumLine());
	#endif
	}
	;

variant_part : CASE_Lex simple_name IS_Lex pragma_s variant_s END_Lex CASE_Lex ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Variant_Part,$2,$4,$5,$1->getNumLine());
	#endif
	}
	;

variant_s : variant
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| variant_s variant
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_List_Variant,$1,$2,$1->getNumLine());
	#endif
	}
	;

variant : WHEN_Lex choice_s ARROW_Lex pragma_s comp_list
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Variant,$2,$4,$5,$1->getNumLine());
	#endif
	}
	;

choice_s : choice
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| choice_s '|' choice
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_List_Choice,$1,$3,$1->getNumLine());
	#endif
	}
	;

choice : expression
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| discrete_with_range
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| OTHERS_Lex
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Others,$1->getNumLine());
	#endif
	}
	;

discrete_with_range : name range_constraint
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Discrete_With_Range,$1,$2,$1->getNumLine());
	#endif
	}
	| range
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	;

access_type : ACCESS_Lex subtype_ind
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Access_Type,$2,$1->getNumLine());
	#endif
	}
	| ACCESS_Lex CONSTANT_Lex subtype_ind
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Access_Constant_Type,$3,$1->getNumLine());
	#endif
	}
	| ACCESS_Lex ALL_Lex subtype_ind
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Access_All_Type,$3,$1->getNumLine());
	#endif
	}
	| ACCESS_Lex prot_opt PROCEDURE_Lex formal_part_opt
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Access_Type,$2,$4,$1->getNumLine());
	#endif
	}
	| ACCESS_Lex prot_opt FUNCTION_Lex formal_part_opt RETURN_Lex mark
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Access_Type,$2,$4,$6,$1->getNumLine());
	#endif
	}
	;

prot_opt :
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	}
	| PROTECTED_Lex
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Protected_Opt,$1->getNumLine());
	#endif
	}
	;

decl_part :
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	}
	| decl_item_or_body_s1
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	;

decl_item_s :
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	} 
	| decl_item_s1
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	;

decl_item_s1 : decl_item
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| decl_item decl_item_s1
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_List_Item_Decl, $1, $2 ,$1->getNumLine());
	#endif
	}
	;

decl_item : decl
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| use_clause
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| rep_spec
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| pragma
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	;

decl_item_or_body_s1 : decl_item_or_body
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| decl_item_or_body_s1 decl_item_or_body
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_List_Decl_Item_Or_Body, $1, $2 ,$1->getNumLine());
	#endif
	}
	;

decl_item_or_body : body
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| decl_item
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	;

body : subprog_body
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| pkg_body
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| task_body
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| prot_body
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	;

name : simple_name
	{
	
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| indexed_comp
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| selected_comp
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| attribute
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| operator_symbol
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	;

mark : simple_name
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| mark '\'' attribute_id
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Mark_Quote, $1, $3, $1->getNumLine());
	#endif
	}
	| mark '.' simple_name
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Mark_Point, $1, $3, $1->getNumLine());
	#endif
	}
	;

simple_name : IDF_Lex
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	;

compound_name : simple_name
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| compound_name '.' simple_name
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Compound_Name, $1, $3, $1->getNumLine());
	#endif
	}
	;

c_name_list : compound_name
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	 | c_name_list ',' compound_name
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_List_C_Name, $1, $3, $1->getNumLine());
	#endif
	}
	;

used_char : QUOTECHAR_Lex
	;

operator_symbol : CONSTCHAINE_Lex
	;

indexed_comp : name '(' value_s ')'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Indexed_Comp, $1, $3, $1->getNumLine());
	#endif
	}
	;

value_s : value
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| value_s ',' value
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_List_Value, $1, $3, $1->getNumLine());
	#endif
	}
	;

value : expression
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| comp_assoc
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| discrete_with_range
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| error
	;

selected_comp : name '.' simple_name
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Selected_Comp, $1, $3, $1->getNumLine());
	#endif
	}
	| name '.' used_char
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Selected_Comp, $1, $3, $1->getNumLine());
	#endif
	}
	| name '.' operator_symbol
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Selected_Comp, $1, $3, $1->getNumLine());
	#endif
	}
	| name '.' ALL_Lex
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Selected_Comp_All, $1,$1->getNumLine());
	#endif
	}
	;

attribute : name '\'' attribute_id
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Attribute, $1, $3, $1->getNumLine());
	#endif
	}
	;

attribute_id : IDF_Lex
	{
	#ifdef ARBRE
	$$ = $1 ;
	#endif
	}
	| DIGITS_Lex
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Digits, $1->getNumLine());
	#endif
	}
	| DELTA_Lex
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Delta,$1->getNumLine());
	#endif
	}
	| ACCESS_Lex
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Access,$1->getNumLine());
	#endif
	}
	;

literal : CONSTREEL_Lex
	{
	#ifdef ARBRE
	$$ = $1 ;
	#endif
	}
	| CONSTENT_Lex
	{
	#ifdef ARBRE
	$$ = $1 ;
	#endif
	}
	| used_char
	{
	#ifdef ARBRE
	$$ = $1 ;
	#endif
	}
	| NULL_Lex
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Null, $1->getNumLine());
	#endif
	}
	;

aggregate : '(' comp_assoc ')'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Aggregate,$2, $1->getNumLine());
	#endif
	}
	| '(' value_s_2 ')'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Aggregate,$2, $1->getNumLine());
	#endif
	}
	| '(' expression WITH_Lex value_s ')'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Aggregate,$2,$4, $1->getNumLine());
	#endif
	}
	| '(' expression WITH_Lex NULL_Lex RECORD_Lex ')'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Aggregate_Null_Record,$2, $1->getNumLine());
	#endif
	}
	| '(' NULL_Lex RECORD_Lex ')'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Aggregate_Null_Record, $1->getNumLine());
	#endif
	}
	;

value_s_2 : value ',' value
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Value2, $1, $3, $1->getNumLine());
	#endif
	}
	| value_s_2 ',' value
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_List_Value2, $1, $3, $1->getNumLine());
	#endif
	}
	;

comp_assoc : choice_s ARROW_Lex expression
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Component_Association, $1, $3, $1->getNumLine());
	#endif
	}
	;

expression : relation
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| expression AND_Lex relation
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_And, $1 , $3, $1->getNumLine());
	#endif
	}
	| expression OR_Lex relation
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Or, $1 , $3, $1->getNumLine());
	#endif
	}
	| expression XOR_Lex relation
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Exclusive_Or, $1 , $3, $1->getNumLine());
	#endif
	}
	| expression AND_Lex THEN_Lex relation
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_And_Then, $1 , $4, $1->getNumLine());
	#endif
	}
	| expression OR_Lex ELSE_Lex relation
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Or_Else, $1 , $4, $1->getNumLine());
	#endif
	}
	;




relation : simple_expression
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| simple_expression '=' simple_expression
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Equal, $1 , $3, $1->getNumLine());
	#endif
	}
	| simple_expression DIFF_Lex simple_expression
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Non_Equal, $1 , $3, $1->getNumLine());
	#endif
	}
	| simple_expression '<' simple_expression
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Less, $1 , $3, $1->getNumLine());
	#endif
	}
	| simple_expression INFEGAL_Lex simple_expression
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Less_Equal, $1 , $3, $1->getNumLine());
	#endif
	}
	| simple_expression '>' simple_expression
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Sup, $1 , $3, $1->getNumLine());
	#endif
	}
	| simple_expression SUPEGAL_Lex simple_expression
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Sup_Equal, $1 , $3, $1->getNumLine());
	#endif
	}
	| simple_expression IN_Lex range
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_In, $1 , $3, $1->getNumLine());
	#endif
	}
	| simple_expression NOT_Lex IN_Lex range
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Not_In, $1 , $4, $1->getNumLine());
	#endif
	}
	| simple_expression IN_Lex name
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_In, $1 , $3, $1->getNumLine());
	#endif
	}
	| simple_expression NOT_Lex IN_Lex name
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Not_In, $1 , $4, $1->getNumLine());
	#endif
	}
	;



simple_expression : '+' term
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Unary_Plus, $2, $1->getNumLine());
	#endif
	}
	| '-' term
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Unary_Minor, $2, $1->getNumLine());
	#endif
	}
	| term
	{
	#ifdef ARBRE
	$$ = $1 ;
	#endif
	}
	| simple_expression '+' term
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Plus, $1, $3,$1->getNumLine());
	#endif
	}
	| simple_expression '-' term
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Minor, $1, $3, $1->getNumLine());
	#endif
	}
	| simple_expression '&' term
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_And_Com, $1, $3, $1->getNumLine());
	#endif
	}
	;

term    : factor
	{
	#ifdef ARBRE
	$$ = $1 ;
	#endif
	}
	| term '*' factor
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Mult, $1, $3, $1->getNumLine());
	#endif
	}
	| term '/' factor
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Div, $1, $3, $1->getNumLine());
	#endif
	}
	| term MOD_Lex factor
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Mod, $1, $3, $1->getNumLine());
	#endif
	}
	| term REM_Lex factor
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Rem, $1, $3, $1->getNumLine());
	#endif
	}
	;



factor : primary
	{
	#ifdef ARBRE
	$$ = $1 ;
	#endif
	}
	| NOT_Lex primary
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Not, $2, $1->getNumLine());
	#endif
	}
	| ABS_Lex primary
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Abs, $2, $1->getNumLine());
	#endif
	}
	| primary POWER_Lex primary
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Power, $1, $3, $1->getNumLine());
	#endif
	}
	;

primary : literal
	{
	#ifdef ARBRE
	$$ = $1 ;
	#endif
	}
	| name
	{
	#ifdef ARBRE
	$$ = $1 ;
	#endif
	}
	| allocator
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| qualified
	{
	#ifdef ARBRE
	$$ = $1 ;
	#endif
	}
	| parenthesized_primary
	{
	#ifdef ARBRE
	$$ = $1 ;
	#endif
	}
	;

parenthesized_primary : aggregate
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| '(' expression ')'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Parenthesized_Primary, $2, $1->getNumLine());
	#endif
	}
	;

qualified : name '\'' parenthesized_primary
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Qualified, $1,$3, $1->getNumLine());
	#endif
	}
	;

allocator : NEW_Lex name
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Allocator, $2, $1->getNumLine());
	#endif
	}
	| NEW_Lex qualified
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Allocator, $2, $1->getNumLine());
	#endif
	}
	;

statement_s : statement
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| statement_s statement
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_List_Statement,$1,$2,$1->getNumLine());
	#endif
	}
	;

statement : unlabeled
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| label statement
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Statement,$1,$2,$1->getNumLine());
	#endif
	}
	;

unlabeled : simple_stmt
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| compound_stmt
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| pragma
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	;

simple_stmt : null_stmt
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| assign_stmt
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| exit_stmt
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| return_stmt
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| goto_stmt
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| procedure_call
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| delay_stmt
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| abort_stmt
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| raise_stmt
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| code_stmt
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| requeue_stmt
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| error ';'
	;

compound_stmt : if_stmt
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| case_stmt
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| loop_stmt
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| block
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| accept_stmt
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| select_stmt
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	;

label : LABEL_LEFT_Lex IDF_Lex LABEL_RIGHT_Lex
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Label,$2,$1->getNumLine());  
	#endif
	}
	;

null_stmt : NULL_Lex ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Null_Statement,$1->getNumLine());  
	#endif
	}
	;

assign_stmt : name AFFECT_Lex expression ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Affect,$1,$3,$1->getNumLine()); 
	#endif
	}
	;

if_stmt : IF_Lex cond_clause_s else_opt END_Lex IF_Lex ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_If,$2,$3,$1->getNumLine()); 
	#endif
	}
	;

cond_clause_s : cond_clause
	{
	#ifdef ARBRE
	$$ = $1;  
	#endif
	}
	| cond_clause ELSIF_Lex cond_clause_s
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_List_Condition_Clause,$1,$3,$1->getNumLine()); 
	#endif
	}
	;

cond_clause : condition THEN_Lex statement_s
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Condition_Clause,$1,$3,$1->getNumLine()); 
	#endif
	}
	;

condition : expression
	{
	#ifdef ARBRE
	$$ = $1;  
	#endif
	}
	;

else_opt :
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);  
	#endif
	}
	| ELSE_Lex statement_s
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Else,$2,$1->getNumLine()); 
	#endif
	}
	;

case_stmt : CASE_Lex expression IS_Lex pragma_s alternative_s END_Lex CASE_Lex ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Case,$2,$4,$5,$1->getNumLine()); 
	#endif
	}
	;



alternative_s :
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber); 
	#endif
	}
	| alternative alternative_s
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_List_Alternative,$1,$2,$1->getNumLine()); 
	#endif
	}
	;

alternative : WHEN_Lex choice_s ARROW_Lex statement_s
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Alternative,$2,$4,$1->getNumLine()); 
	#endif
	}
	;

loop_stmt : label_opt iteration basic_loop id_opt ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Loop,$1,$2,$3,$4,$1->getNumLine()); 
	#endif
	}
	;

label_opt :
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);  
	#endif
	}
	| IDF_Lex ':'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Label_Loop,$1,$1->getNumLine()); 
	#endif
	}
	;

iteration :
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);  
	#endif
	}
	| WHILE_Lex condition
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Iteration,$2,$1->getNumLine()); 
	#endif
	}
	| iter_part reverse_opt discrete_range
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Iteration,$1,$2,$3,$1->getNumLine()); 
	#endif
	}
	;

iter_part : FOR_Lex IDF_Lex IN_Lex
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Iterative_Part,$2,$1->getNumLine()); 
	#endif
	}
	;

reverse_opt :
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);  
	#endif
	}
	| REVERSE_Lex
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Reverse,$1,$1->getNumLine()); 
	#endif
	}
	;

basic_loop : LOOP_Lex statement_s END_Lex LOOP_Lex
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Basic_Loop,$2,$1->getNumLine()); 
	#endif
	}
	;

id_opt :
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);  
	#endif
	}
	| designator
	{
	#ifdef ARBRE
	$$ = $1;  
	#endif
	}
	;

block : label_opt block_decl block_body END_Lex id_opt ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Block,$1,$2,$3,$5, $1->getNumLine());
	#endif
	}
	;

block_decl :
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	}
	| DECLARE_Lex decl_part
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Block_Decl,$2,$1->getNumLine());
	#endif
	}
	;

block_body : BEGIN_Lex handled_stmt_s
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Block_Body,$2, $1->getNumLine());
	#endif
	}
	;

handled_stmt_s : statement_s except_handler_part_opt
 	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Handler_Statement,$1,$2, $1->getNumLine());
	#endif
	}
	; 

except_handler_part_opt :
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	}
	| except_handler_part
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	;

exit_stmt : EXIT_Lex name_opt when_opt ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Exit,$2,$3,$1->getNumLine());
	#endif
	}
	;



name_opt :
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	}
	| name
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	;

when_opt :
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	}
	| WHEN_Lex condition
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_When, $2,$1->getNumLine());
	#endif
	}
	;

return_stmt : RETURN_Lex ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Return, $1->getNumLine());
	#endif
	}
	| RETURN_Lex expression ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Return, $2, $1->getNumLine());
	#endif
	}
	;

goto_stmt : GOTO_Lex name ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Goto, $2, $1->getNumLine());
	#endif
	}
	;

subprog_decl : subprog_spec ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Subprog_Decl,$1, $1->getNumLine());
	#endif
	}
	| generic_subp_inst ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Generic_Subprog_Inst,$1, $1->getNumLine());
	#endif
	}
	| subprog_spec IS_Lex ABSTRACT_Lex ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Abstract_Subprog_Decl,$1, $1->getNumLine());
	#endif
	}
	;

subprog_spec : PROCEDURE_Lex compound_name formal_part_opt
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Subprog_Spec,$2,$3, $1->getNumLine());
	#endif
	}
	| FUNCTION_Lex designator formal_part_opt RETURN_Lex name
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Subprog_Spec,$2,$3,$5, $1->getNumLine());
	#endif
	}
	| FUNCTION_Lex designator  /* for generic inst and generic rename */
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Subprog_Spec,$2, $1->getNumLine());
	#endif
	}
	;

designator : compound_name
	{
	#ifdef ARBRE
	$$= $1;
	#endif
	}
	| CONSTCHAINE_Lex
	;

formal_part_opt :
	{
	#ifdef ARBRE
	$$= new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	} 
	| formal_part
	{
	#ifdef ARBRE
	$$= $1;
	#endif
	}
	;

formal_part : '(' param_s ')'
	{
	#ifdef ARBRE
	$$= new tree(Node_Ada_C_Formal_Part,$2, $1->getNumLine());
	#endif
	}
	;

param_s : param
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| param_s ';' param
	{
	#ifdef ARBRE
	$$= new tree(Node_Ada_List_Parameter,$1, $3,$1->getNumLine());
	#endif
	}
	;

param : def_id_s ':' mode mark init_opt
	{
	#ifdef ARBRE
	$$= new tree(Node_Ada_Parameter,$1, $3,$4,$5,$1->getNumLine());
	#endif
	}
	| error
	;

mode :	{
	#ifdef ARBRE
	$$= new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	}
	| IN_Lex
	{
	#ifdef ARBRE
	$$= new tree(Node_Ada_Mode_In,$1->getNumLine());
	#endif
	}
	| OUT_Lex
	{
	#ifdef ARBRE
	$$= new tree(Node_Ada_Mode_Out,$1->getNumLine());
	#endif
	}
	| IN_Lex OUT_Lex
	{
	#ifdef ARBRE
	$$= new tree(Node_Ada_Mode_In_Out,$1->getNumLine());
	#endif
	}
	| ACCESS_Lex
	{
	#ifdef ARBRE
	$$= new tree(Node_Ada_Mode_Access,$1->getNumLine());
	#endif
	}
	;


subprog_body : subprog_spec IS_Lex decl_part block_body END_Lex id_opt ';'
	 {
	 #ifdef ARBRE
	 $$ = new tree(Node_Ada_Subprog_Body,$1,$3,$4,$6,$1->getNumLine());
	 #endif
	 }
	;

procedure_call : name ';'
	{
	 #ifdef ARBRE
	 $$ = new tree(Node_Ada_Procedure_Call,$1,$1->getNumLine());
	 #endif
	 }
	;

pkg_decl : pkg_spec ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Package_Decl,$1,$1->getNumLine());
	#endif
	}
	| generic_pkg_inst ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Package_Decl,$1,$1->getNumLine());
	#endif
	}
	;

pkg_spec : PACKAGE_Lex compound_name IS_Lex 
	     decl_item_s private_part END_Lex c_id_opt
	  {
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Package_Spec, $2, $4, $5, $7,$1->getNumLine());
	#endif
	}
	;

private_part :
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	}
	| PRIVATE_Lex decl_item_s
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Private_Part,$2,$1->getNumLine());
	#endif
	}
	;

c_id_opt :
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	} 
	| compound_name
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	;

pkg_body : PACKAGE_Lex BODY_Lex compound_name IS_Lex decl_part body_opt END_Lex c_id_opt ';'
	 {
	 #ifdef ARBRE
	 $$ = new tree(Node_Ada_Package_Body, $3, $5, $6, $8,$1->getNumLine());
	 #endif
	 }
	;

body_opt :
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	} 
	| block_body
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	;

private_type : tagged_opt limited_opt PRIVATE_Lex
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Private_Type,$1, $2, $1->getNumLine());
	#endif
	} 
	;

limited_opt :
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	} 
	| LIMITED_Lex
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Limited,$1->getNumLine());
	#endif
	} 
	;

use_clause : USE_Lex name_s ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Use_Clause,$2,$1->getNumLine());
	#endif
	}
	| USE_Lex TYPE_Lex name_s ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Use_Clause_Type,$3,$1->getNumLine());
	#endif
	}
	;

name_s : name
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| name_s ',' name
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_List_Name,$1, $3,$1->getNumLine());
	#endif
	}
	;

rename_decl : def_id_s ':' object_qualifier_opt subtype_ind renames ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Rename_Decl,$1,$3,$4,$5,$1->getNumLine());
	#endif
	}
	| def_id_s ':' EXCEPTION_Lex renames ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Rename_Decl,$1,$4,$1->getNumLine());
	#endif
	}
	| rename_unit
	{
	#ifdef ARBRE
	$$ = $1 ;
	#endif
	}
	;

rename_unit : PACKAGE_Lex compound_name renames ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Rename_Unit_Package,$2,$3,$1->getNumLine());
	#endif
	}
	| subprog_spec renames ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Rename_Unit,$1,$2,$1->getNumLine());
	#endif
	}
	| generic_formal_part PACKAGE_Lex compound_name renames ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Rename_Unit_Package,$1,$3,$4,$1->getNumLine());
	#endif
	}
	| generic_formal_part subprog_spec renames ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Rename_Unit,$1,$2,$3,$1->getNumLine());
	#endif
	}
	;

renames : RENAMES_Lex name
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Renames,$2,$1->getNumLine());
	#endif
	}
	;

task_decl : task_spec ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Task_Decl,$1,$1->getNumLine());
	#endif
	}
	;

task_spec : TASK_Lex simple_name task_def
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Task_Spec,$2,$3,$1->getNumLine());
	#endif
	}
	| TASK_Lex TYPE_Lex simple_name discrim_part_opt task_def
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Task_Spec,$3,$4,$5,$1->getNumLine());
	#endif
	}
	;

task_def :
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	}
	| IS_Lex entry_decl_s rep_spec_s task_private_opt END_Lex id_opt
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Task_Def,$2,$3,$4,$6,$1->getNumLine());
	#endif
	}
	;

task_private_opt :
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	}
	| PRIVATE_Lex entry_decl_s rep_spec_s
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Task_Private_Opt,$2,$3,$1->getNumLine());
	#endif
	}
	;

task_body : TASK_Lex BODY_Lex simple_name IS_Lex
	       decl_part block_body END_Lex id_opt ';'
	 {
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Task_Body,$3,$5,$6,$8,$1->getNumLine());
	#endif
	}      
	;

prot_decl : prot_spec ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Prot_Decl,$1,$1->getNumLine());
	#endif
	}
	;

prot_spec : PROTECTED_Lex IDF_Lex prot_def
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Prot_Spec,$2,$3,$1->getNumLine());
	#endif
	}
	| PROTECTED_Lex TYPE_Lex simple_name discrim_part_opt prot_def
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Prot_Spec,$3,$4,$5,$1->getNumLine());
	#endif
	}
	;

prot_def : IS_Lex prot_op_decl_s prot_private_opt END_Lex id_opt
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Prot_Def,$2,$3,$5,$1->getNumLine());
	#endif
	}
	;

prot_private_opt :
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	}
	| PRIVATE_Lex prot_elem_decl_s 
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Prot_Private_Opt,$2,$1->getNumLine());
	#endif
	}
	;

prot_op_decl_s : 
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	}
	| prot_op_decl_s prot_op_decl
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Prot_Op_Decl_s,$1,$2,$1->getNumLine());
	#endif
	}
	;

prot_op_decl : entry_decl
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| subprog_spec ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Prot_Op_Decl,$1,$1->getNumLine());
	#endif
	}
	| rep_spec
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| pragma
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	;

prot_elem_decl_s : 
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	}
	| prot_elem_decl_s prot_elem_decl
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Prot_Elem_Decl_s,$1,$2,$1->getNumLine());
	#endif
	}
	;

prot_elem_decl : prot_op_decl
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	|
	comp_decl 
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	;

prot_body : PROTECTED_Lex BODY_Lex simple_name IS_Lex
	       prot_op_body_s END_Lex id_opt ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Prot_Body,$3,$5,$7,$1->getNumLine());
	#endif
	}
	;

prot_op_body_s : pragma_s
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| prot_op_body_s prot_op_body pragma_s
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Prot_Op_Body_s,$1,$2,$3,$1->getNumLine());
	#endif
	}
	;

prot_op_body : entry_body
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| subprog_body
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| subprog_spec ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Prot_Op_Body,$1,$1->getNumLine());
	#endif
	}
	;

entry_decl_s : pragma_s
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| entry_decl_s entry_decl pragma_s
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Entry_Decl_s,$1,$2,$3,$1->getNumLine());
	#endif
	}
	;

entry_decl : ENTRY_Lex IDF_Lex formal_part_opt ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Entry_Decl,$2,$3,$1->getNumLine());
	#endif
	}
	| ENTRY_Lex IDF_Lex '(' discrete_range ')' formal_part_opt ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Entry_Decl,$2,$4,$6,$1->getNumLine());
	#endif
	}
	;

entry_body : ENTRY_Lex IDF_Lex formal_part_opt WHEN_Lex condition entry_body_part
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Entry_Body,$2,$3,$5,$6,$1->getNumLine());
	#endif
	}
	| ENTRY_Lex IDF_Lex '(' iter_part discrete_range ')' 
		formal_part_opt WHEN_Lex condition entry_body_part
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Entry_Body,$2,$4,$5,$7,$9,$10,$1->getNumLine());
	#endif
	}
	;

entry_body_part : ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Entry_Body_Part,$1->getNumLine());
	#endif
	}
	| IS_Lex decl_part block_body END_Lex id_opt ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Entry_Body_Part,$2,$3,$5,$1->getNumLine());
	#endif
	}
	;

rep_spec_s :
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	}
	| rep_spec_s rep_spec pragma_s
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Rep_Spec_s,$1,$2,$3,$1->getNumLine());
	#endif
	}
	;

entry_call : procedure_call
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	;

accept_stmt : accept_hdr ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Accept_Stmt,$1,$1->getNumLine());
	#endif
	}
	| accept_hdr DO_Lex handled_stmt_s END_Lex id_opt ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Accept_Stmt,$1,$3,$5,$1->getNumLine());
	#endif
	}
	;

accept_hdr : ACCEPT_Lex entry_name formal_part_opt
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Accept_Hdr,$2,$3,$1->getNumLine());
	#endif
	}
	;

entry_name : simple_name
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| entry_name '(' expression ')'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Entry_Name,$1,$3,$1->getNumLine());
	#endif
	}
	;

delay_stmt : DELAY_Lex expression ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Delay_Stmt,$2,$1->getNumLine());
	#endif
	}
	| DELAY_Lex UNTIL_Lex expression ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Delay_Stmt_Until,$3,$1->getNumLine());
	#endif
	}
	;

select_stmt : select_wait
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| async_select
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| timed_entry_call
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| cond_entry_call
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	;

select_wait : SELECT_Lex guarded_select_alt or_select else_opt
	      END_Lex SELECT_Lex ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Select_Wait,$2,$3,$4,$1->getNumLine());
	#endif
	}
	;

guarded_select_alt : select_alt
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| WHEN_Lex condition ARROW_Lex select_alt
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Guarded_Select_Alt,$2,$4,$1->getNumLine());
	#endif
	}
	;

or_select :
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	}
	| or_select OR_Lex guarded_select_alt
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Or_Select,$1,$3,$1->getNumLine());
	#endif
	}
	;

select_alt : accept_stmt stmts_opt
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Select_Alt,$1,$2,$1->getNumLine());
	#endif
	}
	| delay_stmt stmts_opt
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Select_Alt,$1,$2,$1->getNumLine());
	#endif
	}
	| TERMINATE_Lex ';'
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Select_Alt,$1->getNumLine());
	#endif
	}
	;

delay_or_entry_alt : delay_stmt stmts_opt
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Delay_Or_Entry_Alt,$1,$2,$1->getNumLine());
	#endif
	}
	| entry_call stmts_opt
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Delay_Or_Entry_Alt,$1,$2,$1->getNumLine());
	#endif
	}
	;
	
async_select : SELECT_Lex delay_or_entry_alt
	       THEN_Lex ABORT_Lex statement_s
	       END_Lex SELECT_Lex ';'
	       {	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Async_Select,$2,$5,$1->getNumLine());
	#endif
	}
	;

timed_entry_call : SELECT_Lex entry_call stmts_opt 
		   OR_Lex delay_stmt stmts_opt
	           END_Lex SELECT_Lex ';'
		   {	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Timed_Entry_Call,$2,$3,$5,$6,$1->getNumLine());
	#endif
	}
	;

cond_entry_call : SELECT_Lex entry_call stmts_opt 
		  ELSE_Lex statement_s
	          END_Lex SELECT_Lex ';'
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Cond_Entry_Call,$2,$3,$5,$1->getNumLine());
	#endif
	}
	;

stmts_opt :
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	}
	| statement_s
	{	
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	;

abort_stmt : ABORT_Lex name_s ';'
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Abort_Stmt,$2,$1->getNumLine());
	#endif
	}
	;

compilation :
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	}
	| compilation comp_unit
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_List_Compilation_Unit, $1, $2, $1->getNumLine());
	#endif
	}
	| pragma pragma_s
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_List_Pragma, $1,$2, $1->getNumLine());
  	#endif
	}
	;

comp_unit : context_spec private_opt unit pragma_s
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Compilation_Unit, $1, $2, $3, $4, $1->getNumLine());
  	#endif
	}
	| private_opt unit pragma_s
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Compilation_Unit, $1, $2, $3, $1->getNumLine());
  	#endif
	}
	;

private_opt :
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
  	#endif
	}
	| PRIVATE_Lex
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Private,$1->getNumLine());
  	#endif
	}
	;

context_spec : with_clause use_clause_opt
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Context_Specification, $1, $2, $1->getNumLine());
  	#endif
	}
	| context_spec with_clause use_clause_opt
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Context_Specification, $1, $2, $3,$1->getNumLine());
  	#endif
	}
	| context_spec pragma
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Context_Specification, $1, $2, $1->getNumLine());
  	#endif
	}
	;

with_clause : WITH_Lex c_name_list ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Clause_Width, $2, $1->getNumLine());
  	#endif
	}
	;

use_clause_opt :
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
  	#endif
	}
	| use_clause_opt use_clause
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Clause_Use_Option,$1, $2, $1->getNumLine());
  	#endif
	}
	;

unit : pkg_decl
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| pkg_body
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| subprog_decl
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| subprog_body
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| subunit
	{	
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| generic_decl
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| rename_unit
	{	
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	;

subunit : SEPARATE_Lex '(' compound_name ')'
	      subunit_body
	 {
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Subunit,$3, $5, $1->getNumLine());
  	#endif
	}     
	;

subunit_body : subprog_body
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| pkg_body
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| task_body
	{	
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| prot_body
	{	
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	;

body_stub : TASK_Lex BODY_Lex simple_name IS_Lex SEPARATE_Lex ';'
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Body_Stub_Task,$3, $1->getNumLine());
  	#endif
	}
	| PACKAGE_Lex BODY_Lex compound_name IS_Lex SEPARATE_Lex ';'
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Body_Stub_Package,$3, $1->getNumLine());
  	#endif
	}
	| subprog_spec IS_Lex SEPARATE_Lex ';'
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Body_Stub_SubProg,$1, $1->getNumLine());
  	#endif
	}
	| PROTECTED_Lex BODY_Lex simple_name IS_Lex SEPARATE_Lex ';'
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Body_Stub_Prot,$3, $1->getNumLine());
  	#endif
	}
	;

exception_decl : def_id_s ':' EXCEPTION_Lex ';'
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Exception_Decl,$1, $1->getNumLine());
  	#endif
	}
	;

except_handler_part : EXCEPTION_Lex exception_handler
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Except_Handler_Part,$2, $1->getNumLine());
  	#endif
	}
	| except_handler_part exception_handler
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Except_Handler_Part,$1,$2, $1->getNumLine());
  	#endif
	}
	;

exception_handler : WHEN_Lex except_choice_s ARROW_Lex statement_s
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Exception_Handler,$2,$4, $1->getNumLine());
  	#endif
	}
	| WHEN_Lex IDF_Lex ':' except_choice_s ARROW_Lex statement_s
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Exception_Handler,$2,$4,$6, $1->getNumLine());
  	#endif
	}
	;

except_choice_s : except_choice
	{	
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| except_choice_s '|' except_choice
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Except_Choice_s,$1,$3, $1->getNumLine());
  	#endif
	}
	;

except_choice : name
	{	
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| OTHERS_Lex
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Others,$1->getNumLine());
	#endif
	}
	;

raise_stmt : RAISE_Lex name_opt ';'
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Raise_Stmt,$2, $1->getNumLine());
  	#endif
	}
	;

requeue_stmt : REQUEUE_Lex name ';'
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Requeue_Stmt,$2, $1->getNumLine());
  	#endif
	}
	| REQUEUE_Lex name WITH_Lex ABORT_Lex ';'
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Requeue_Stmt_With,$2, $1->getNumLine());
  	#endif
	}
	;

generic_decl : generic_formal_part subprog_spec ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Generic_Decl,$1,$2,$1->getNumLine());
	#endif
	}
	| generic_formal_part pkg_spec ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Generic_Decl,$1,$2,$1->getNumLine());
	#endif
	}
	;

generic_formal_part : GENERIC_Lex
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Generic,$1->getNumLine());
	#endif
	}
	| generic_formal_part generic_formal
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Generic_Formal_Part,$1,$2,$1->getNumLine());
	#endif
	}
	;

generic_formal : param ';'
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Generic_Formal,$1,$1->getNumLine());
	#endif
	}
	| TYPE_Lex simple_name generic_discrim_part_opt IS_Lex generic_type_def ';'
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Generic_Formal,$2,$3,$5,$1->getNumLine());
	#endif
	}
	| WITH_Lex PROCEDURE_Lex simple_name formal_part_opt subp_default ';'
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Generic_Formal_Procedure,$3,$4,$5,$1->getNumLine());
	#endif
	}
	| WITH_Lex FUNCTION_Lex designator formal_part_opt RETURN_Lex name subp_default ';'
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Generic_Formal,$3,$4,$6,$7,$1->getNumLine());
	#endif
	}
	| WITH_Lex PACKAGE_Lex simple_name IS_Lex NEW_Lex name '(' BOX_Lex ')' ';'
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Generic_Formal_Package_Box,$3,$6,$1->getNumLine());
	#endif
	}
	| WITH_Lex PACKAGE_Lex simple_name IS_Lex NEW_Lex name ';'
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Generic_Formal_Package,$3,$6,$1->getNumLine());
	#endif
	}
	| use_clause
	{	
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	;

generic_discrim_part_opt :
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	}
	| discrim_part
	{
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| '(' BOX_Lex ')'
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Generic_Discrim_Part_Opt,$1->getNumLine());
	#endif
	}
	;

subp_default :
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	}
	| IS_Lex name
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Subp_Default,$2,$1->getNumLine());
	#endif
	}
	| IS_Lex BOX_Lex
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Subp_Default,$1->getNumLine());
	#endif
	}
	;

generic_type_def : '(' BOX_Lex ')'
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Generic_Type_Def_Box,$1->getNumLine());
	#endif
	}
	| RANGE_Lex BOX_Lex
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Range_Box,$1->getNumLine());
	#endif
	}
	| MOD_Lex BOX_Lex
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Mod_Box,$1->getNumLine());
	#endif
	}
	| DELTA_Lex BOX_Lex
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Delta_Box,$1->getNumLine());
	#endif
	}
	| DELTA_Lex BOX_Lex DIGITS_Lex BOX_Lex
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Delta_Box_Digits_Box,$1->getNumLine());
	#endif
	}
	| DIGITS_Lex BOX_Lex
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Digits_Box_Lex,$1->getNumLine());
	#endif
	}
	| array_type
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Generic_Type_Def,$1,$1->getNumLine());
	#endif
	}
	| access_type
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Generic_Type_Def,$1,$1->getNumLine());
	#endif
	}
	| private_type
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Generic_Type_Def,$1,$1->getNumLine());
	#endif
	}
	| generic_derived_type
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Generic_Type_Def,$1,$1->getNumLine());
	#endif
	}
	;

generic_derived_type : NEW_Lex subtype_ind
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Generic_Derived_Type,$2,$1->getNumLine());
	#endif
	}
	| NEW_Lex subtype_ind WITH_Lex PRIVATE_Lex
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Generic_Derived_Type_Private,$2,$1->getNumLine());
	#endif
	}
	| ABSTRACT_Lex NEW_Lex subtype_ind WITH_Lex PRIVATE_Lex
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Generic_Derived_Type_Abstract_Private,$3,$1->getNumLine());
	#endif
	}
	;

generic_subp_inst : subprog_spec IS_Lex generic_inst
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Generic_Subp_Inst,$1,$3,$1->getNumLine());
	#endif
	}
	;

generic_pkg_inst : PACKAGE_Lex compound_name IS_Lex generic_inst
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Generic_Package_Inst, $2, $4, $1->getNumLine());
  	#endif
	}
	;

generic_inst : NEW_Lex name
	{
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Generic_Inst, $2, $1->getNumLine());
  	#endif
	}
	;

rep_spec : attrib_def
	{	
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| record_type_spec
	{	
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	| address_spec
	{	
	#ifdef ARBRE
	$$ = $1;
	#endif
	}
	;

attrib_def : FOR_Lex mark USE_Lex expression ';'
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Attrib_Def, $2,$4, $1->getNumLine());
  	#endif
	}
	;

record_type_spec : FOR_Lex mark USE_Lex RECORD_Lex align_opt comp_loc_s END_Lex RECORD_Lex ';'
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Record_Type_Spec, $2,$5,$6, $1->getNumLine());
  	#endif
	}
	;

align_opt :
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	}
	| AT_Lex MOD_Lex expression ';'
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Align_Opt, $3, $1->getNumLine());
  	#endif
	}
	;

comp_loc_s :
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_C_Empty,g_LineNumber);
	#endif
	}
	| comp_loc_s mark AT_Lex expression RANGE_Lex range ';'
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Comp_Loc_s,$1,$2,$4,$6,$1->getNumLine());
  	#endif
	}
	;

address_spec : FOR_Lex mark USE_Lex AT_Lex expression ';'
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Address_Spec,$2,$5,$1->getNumLine());
  	#endif
	}
	;

code_stmt : qualified ';'
	{	
	#ifdef ARBRE
	$$ = new tree(Node_Ada_Code_Stmt,$1,$1->getNumLine());
  	#endif
	}
	;
%%


