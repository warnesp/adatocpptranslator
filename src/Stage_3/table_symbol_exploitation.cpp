/*****************************************************************************
 *                      Ada_to_C_Cpp_Translator
 *****************************************************************************
 * Adatoccpptranslator is a free software which convert Ada code to C/C++ 
 * source code
 * Copyright (C) 2004 Julien THEVENON
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option) 
 * any later version.
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
 * more details.
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 * For further informations : adatoccpptranslator@free.fr
 * 
 * Description: exploitation of symbol table
 *
 * $Log: table_symbol_exploitation.cpp,v $
 * Revision 1.5  2005/03/26 23:45:52  quicky2000
 * Modification of search type algorithm.
 * Add of a new function which return the type of a typed unit
 *
 * Revision 1.4  2005/03/24 19:08:19  quicky2000
 * Update to correct case of include files names
 *
 * Revision 1.3  2005/03/19 13:25:39  quicky2000
 * Update to:
 * _ maintain code
 * _ add value compute facilities
 *
 * Revision 1.2  2005/03/16 22:53:43  quicky2000
 * Update to add comments and include directives due to the new management of subprograms
 *
 * Revision 1.1  2005/03/07 23:53:39  quicky2000
 * Update to:
 * _ move the file from src directory
 * _ modify the include paths due to new organisation of source files
 *
 * Revision 1.3  2005/03/03 23:10:10  quicky2000
 * Update to add implementation of function isAnArray and to correct a condition in a test
 *
 * Revision 1.2  2005/03/03 00:05:23  quicky2000
 * Update to add comments
 *
 * Revision 1.1.1.1  2005/03/01 22:20:48  quicky2000
 * Initial import
 *
 *
 *****************************************************************************/

/* ========================================================================== */
/* DIRECTIVES D'INCLUSION (include)                                           */
/* ========================================================================== */
#include "table_symbol_exploitation.h"

#include "../Table_symbol/access_type.h"
#include "../Table_symbol/access_object_type.h"
#include "../Table_symbol/constant_number.h"
#include "../Table_symbol/derived_type.h"
#include "../Table_symbol/function_spec.h"
#include "../Table_symbol/function_body.h"
#include "../Table_symbol/main_unit.h"
#include "../Table_symbol/package.h"
#include "../Table_symbol/package_rename.h"
#include "../Table_symbol/parameter.h"
#include "../Table_symbol/procedure_body.h"
#include "../Table_symbol/record_type.h"
#include "../Table_symbol/subtype.h"
#include "../Table_symbol/type.h"
#include "../Table_symbol/variable_object.h"
#include "../Table_symbol/variable_array.h"

#include "../Tools/value.h"

#include <math.h>

/* ========================================================================== */
/* PROTOTYPE DES SOUS PROGRAMMES INTERNES	                              */
/* ========================================================================== */

/*****************************************************************************
 * Function name : getDirectPackageSpec 
 *
 * Input :	p_FpLog reference on a FILE
 * 		p_Name reference on a string
 * Output : package_spec* - reference on a package_spec
 * Modified variable : none
 * Description : Function which return a reference on the package spec
 * 	designed by parameter P_Name
 *****************************************************************************/
package_spec* getDirectPackageSpec( FILE *p_FpLog, const char *p_Name );

/*****************************************************************************
 * Function name : getPackageSpec 
 *
 * Input :	p_FpLog reference on a FILE
 * 		p_Name reference on a string
 * 		p_CurrentMainUnit reference on a main_unit
 * Output : package_spec* - reference on a package_spec
 * Modified variable : none
 * Description : Function which return a reference on package_spec correspondig
 * 	to p_Name by using symbol table and links of p_CurrentMainunit
 *****************************************************************************/ 
package_spec* getPackageSpec( FILE *p_FpLog, const char *p_Name,main_unit *p_CurrentMainUnit );

/*****************************************************************************
 * Function name : isAnArray 
 *
 * Input :	p_FpLog reference on a FILE
 * 		p_Type reference on a type
 * Output : array* - reference on an array
 * Modified variable : none
 * Description : Function which return a reference on the array corresponding
 * 	to p_Type
 * 	NULL is returned if p_Type is not an array type
 *****************************************************************************/ 
array* isAnArray( FILE *p_FpLog, type *p_Type );

/*****************************************************************************
 * Function name : isAnArray 
 *
 * Input :	p_FpLog reference on a FILE
 * 		p_Variable reference on a variable
 * Output : array* - reference on an array
 * Modified variable : none
 * Description : Function which return a reference on the array corresponding
 * 	to variable referenced by p_Variable
 *****************************************************************************/ 
array* isAnArray( FILE *p_FpLog, variable *p_Variable );

/*****************************************************************************
 * Function name : searchConstantNumber 
 *
 * Input :	p_FpLog reference on a FILE
 * 		p_Name reference on a string
 * 		p_CurrentMainUnit - reference on a main_unit
 * Output : constant_number* - reference on a constant_number
 * Modified variable : none
 * Description : Function which return a reference on the constant_number whose
 * 	name is p_Name
 * 	NULL is returned if p_Name is not the name of a constant_number
 *****************************************************************************/ 
constant_number* searchConstantNumber( FILE *p_FpLog, const char *p_Name,main_unit *p_CurrentMainUnit );

/*****************************************************************************
 * Function name : searchConstantNumberInDependancies 
 *
 * Input :	p_FpLog reference on a FILE
 * 		p_Name reference on a string
 * 		p_CurrentMainUnit - reference on a main_unit
 * Output : constant_number* - reference on a constant_number
 * Modified variable : none
 * Description : Function which return a reference on the constant_number whose
 * 	name is p_Name
 * 	NULL is returned if p_Name is not the name of a constant_number
 *****************************************************************************/ 
constant_number* searchConstantNumberInDependancies( FILE *p_FpLog, const char *p_Name,main_unit *p_CurrentMainUnit );

/*****************************************************************************
 * Function name : searchFunctionSpec 
 *
 * Input :	p_FpLog reference on a FILE
 * 		p_Name reference on a string
 * 		p_CurrentMainUnit - reference on a main_unit
 * Output : function_spec* - reference on a function_spec
 * Modified variable : none
 * Description : Function which return a reference on the function_spec whose
 * 	name is p_Name
 * 	NULL is returned if p_Name is not the name of a function_spec
 *****************************************************************************/ 
function_spec* searchFunctionSpec( FILE *p_FpLog, const char *p_Name,main_unit *p_CurrentMainUnit );

/*****************************************************************************
 * Function name : searchFunctionSpecInDependancies 
 *
 * Input :	p_FpLog reference on a FILE
 * 		p_Name reference on a string
 * 		p_CurrentMainUnit - reference on a main_unit
 * Output : function_spec* - reference on a function_spec
 * Modified variable : none
 * Description : Function which return a reference on the function_spec whose
 * 	name is p_Name
 * 	NULL is returned if p_Name is not the name of a function_spec
 *****************************************************************************/ 
function_spec* searchFunctionSpecInDependancies( FILE *p_FpLog, const char *p_Name,main_unit *p_CurrentMainUnit );

/*****************************************************************************
 * Function name : searchPackageRename 
 *
 * Input :	p_FpLog reference on a FILE
 * 		p_Name reference on a string
 * 		p_MainUnit reference on a main_unit
 * Output : package_rename* - reference on a package_rename
 * Modified variable : none
 * Description : Function which return a reference on a package rename 
 * 	corresponding to p_Name
 *****************************************************************************/ 
package_rename* searchPackageRename( FILE *p_FpLog, main_unit *p_MainUnit,const char *p_Name );

/*****************************************************************************
 * Function name : searchType 
 *
 * Input :	p_FpLog reference on a FILE
 * 		p_Name reference on a string
 * 		p_CurrentMainUnit - reference on a main_unit
 * Output : type* - reference on a type
 * Modified variable : none
 * Description : Function which return a reference on the type whose name is p_Name
 * 	NULL is returned if p_Type is not an array type
 *****************************************************************************/ 
type* searchType( FILE *p_FpLog, const char *p_Name,main_unit *p_CurrentMainUnit);

/*****************************************************************************
 * Function name : searchType 
 *
 * Input :	p_FpLog reference on a FILE
 * 		p_Name reference on a string
 * 		p_CurrentMainUnit - reference on a main_unit
 * Output : type* - reference on a type
 * Modified variable : none
 * Description : Function which return a reference on the type of typed class
 * 	if type was found. In contrary case type is searched grom its tree representation
 *****************************************************************************/ 
type* searchType( FILE *p_FpLog, typed *p_Typed,main_unit *p_CurrentMainUnit );

/*****************************************************************************
 * Function name : searchTypeInDependancies 
 *
 * Input :	p_FpLog reference on a FILE
 * 		p_Name reference on a string
 * 		p_CurrentMainUnit - reference on a main_unit
 * Output : type* - reference on a type
 * Modified variable : none
 * Description : Function which return a reference on the type whose name is p_Name
 * 	NULL is returned if not type has the name p_Name
 *****************************************************************************/ 
type* searchTypeInDependancies( FILE *p_FpLog, const char *p_Name,main_unit *p_CurrentMainUnit);

/*****************************************************************************
* Function name : searchType 
*
* Input :	p_FpLog - reference on the log file
*			p_Tree	- reference on a tree
*			p_CurrentMainUnit - reference on a main_unit
* Output : type* - Reference on the type represented by node p_Tree
* Modified variable : none
* Description : Function which determines if a node represents a type
*	If the node doesn't represent a type returned value is NULL
*****************************************************************************/
type* searchType( FILE *p_FpLog, tree *p_Tree, main_unit *p_CurrentMainUnit);

/*****************************************************************************
 * Function name : searchVariable 
 *
 * Input :	p_FpLog reference on a FILE
 * 		p_Name reference on a string
 * 		p_CurrentMainUnit - reference on a main_unit
 * Output : variable* - reference on an array
 * Modified variable : none
 * Description : Function which return a reference on the variable corresponding
 * 	to p_Name
 *****************************************************************************/ 
variable* searchVariable( FILE *p_FpLog, const char *p_Name,main_unit *p_CurrentMainUnit );

/*****************************************************************************
 * Function name : searchVariableInDependancies 
 *
 * Input :	p_FpLog reference on a FILE
 * 		p_Name reference on a string
 * 		p_CurrentMainUnit - reference on a main_unit
 * Output : variable* - reference on an array
 * Modified variable : none
 * Description : Function which return a reference on the variable corresponding
 * 	to p_Name
 *****************************************************************************/ 
variable* searchVariableInDependancies( FILE *p_FpLog, const char *p_Name,main_unit *p_CurrentMainUnit );

/* ========================================================================== */
/* IMPLANTATION DES SOUS PROGRAMMES										      */
/* ========================================================================== */

/* $ ------------------------------------------------------------------------ */
/* $ Function name : calculate												  */
/* $																		  */
/* $ Input :	p_FpLog		- reference on a log FILE						  */
/* $			p_Value		- reference on a double which will receive the	  */
/* $						  calculated value								  */
/* $			p_MainUnit	- reference on current main unit				  */
/* $																		  */
/* $ Output : value* - reference on a package_spec	    					  */
/* $ Modified variable : p_Value											  */
/* $ Description : Function which return a reference on the the input value   */
/* $	If the input value can't be calculed an error message is logged		  */
/* $ ------------------------------------------------------------------------ */ 
value* calculate(FILE *p_FpLog, value *p_Value, main_unit *p_MainUnit)
{
	#ifdef TRACE
	printfTraceUp( "calculate", __FILE__, __LINE__);
	#endif

	value *l_Result = p_Value;

	/* Check of input parameters */
	if( p_Value != NULL && p_MainUnit != NULL )
	{
		/* Numeric value of p_Value is not known and is can be computed */
		if( p_Value->isBoolComputed() == 0 || p_Value->isBoolComputable() == 1)
		{
			tree *l_Tree=p_Value->getTree();
			
			switch(l_Tree->getNodeType())
			{
				case Node_Ada_C_Based_Number:
				case Node_Ada_C_Float:
				l_Result->setNumValue(l_Tree->getFloat());
				break;
				
				// abs( x )
				case Node_Ada_Abs:
				{
					value l_LeftMemberValue(l_Tree->getSon(0));
					l_LeftMemberValue = *calculate( p_FpLog, &l_LeftMemberValue, p_MainUnit);
					if(l_LeftMemberValue.isBoolComputed()==0)
					{
						l_Result = l_Result->setUnComputable();
					}
					else
					{	
						l_Result = l_Result->setNumValue(fabs(l_LeftMemberValue.getNumValue()));
					}
				}
				break;
				
				// x & y
				case Node_Ada_C_And_Com:
				case Node_Ada_And_Then:
				case Node_Ada_And:
				{
					value l_LeftMemberValue(l_Tree->getSon(0));
					value l_RightMemberValue(l_Tree->getSon(1));
					l_LeftMemberValue = *calculate( p_FpLog, &l_LeftMemberValue, p_MainUnit);
					l_RightMemberValue = *calculate( p_FpLog, &l_RightMemberValue, p_MainUnit);
					if(l_LeftMemberValue.isBoolComputed()==0 || l_RightMemberValue.isBoolComputed()==0)
					{
						l_Result = l_Result->setUnComputable();
					}
					else
					{	
						l_Result = l_Result->setNumValue( ((int)l_LeftMemberValue.getNumValue()) & ((int)l_RightMemberValue.getNumValue()));
					}
				}
				break;
				
				
				case Node_Ada_Attribute:
					l_Result=new value(p_Value->getTree());
					l_Result->setUnComputable();
				break;
				
				// x / y
				case Node_Ada_C_Div:
				{
					value l_LeftMemberValue(l_Tree->getSon(0));
					value l_RightMemberValue(l_Tree->getSon(1));
					l_LeftMemberValue = *calculate( p_FpLog, &l_LeftMemberValue, p_MainUnit);
					l_RightMemberValue = *calculate( p_FpLog, &l_RightMemberValue, p_MainUnit);
					if(l_LeftMemberValue.isBoolComputed()==0 || l_RightMemberValue.isBoolComputed()==0)
					{
						l_Result = l_Result->setUnComputable();
					}
					else
					{	
						l_Result = l_Result->setNumValue( l_LeftMemberValue.getNumValue() / l_RightMemberValue.getNumValue());
					}
				}
				break;
				
				// x ^ y ( XOR )
				case Node_Ada_Exclusive_Or:
				{
					value l_LeftMemberValue(l_Tree->getSon(0));
					value l_RightMemberValue(l_Tree->getSon(1));
					l_LeftMemberValue = *calculate( p_FpLog, &l_LeftMemberValue, p_MainUnit);
					l_RightMemberValue = *calculate( p_FpLog, &l_RightMemberValue, p_MainUnit);
					if(l_LeftMemberValue.isBoolComputed()==0 || l_RightMemberValue.isBoolComputed()==0)
					{
						l_Result = l_Result->setUnComputable();
					}
					else
					{	
						l_Result = l_Result->setNumValue( ((int)l_LeftMemberValue.getNumValue()) ^ ((int)l_RightMemberValue.getNumValue()));
					}
				}
				break;

				// x == y
				case Node_Ada_Equal:
				{
					value l_LeftMemberValue(l_Tree->getSon(0));
					value l_RightMemberValue(l_Tree->getSon(1));
					l_LeftMemberValue = *calculate( p_FpLog, &l_LeftMemberValue, p_MainUnit);
					l_RightMemberValue = *calculate( p_FpLog, &l_RightMemberValue, p_MainUnit);
					if(l_LeftMemberValue.isBoolComputed()==0 || l_RightMemberValue.isBoolComputed()==0)
					{
						l_Result = l_Result->setUnComputable();
					}
					else
					{	
						l_Result = l_Result->setNumValue( l_LeftMemberValue.getNumValue() == l_RightMemberValue.getNumValue());
					}
				}
				break;

				case Node_Ada_C_Ident:
				{
					// Search of variable whose name is represented by ident
					//printf("%s %i : searchOfVariable \"%s\"\n",__FILE__,__LINE__,getString(l_Tree));
					variable *l_Variable=NULL;
					l_Variable=searchVariable(p_FpLog,getString(l_Tree),p_MainUnit);

					// Variable found
					if(l_Variable!=NULL)
					{
						//printf("%s %i : variable \"%s\" found\n",__FILE__,__LINE__,l_Variable->getName());
						l_Result=calculate(p_FpLog,l_Variable->getInitValue(),p_MainUnit);
					}
						
					// Variable not found
					if(l_Variable==NULL)
					{
						constant_number *l_ConstantNumber=NULL;
						
						// Search of constant number
						if((l_ConstantNumber=searchConstantNumber(p_FpLog,getString( l_Tree),p_MainUnit))!=NULL)
						{
							//printf("%s %i : constant_number %s found\n",__FILE__,__LINE__,l_ConstantNumber->getName());
							l_Result=calculate(p_FpLog,l_ConstantNumber->getInitValue(),p_MainUnit);
						}
					}
					
					
					if(l_Result==NULL)
					{
						printf("%s %i : unable to compute numeric value of \"%s\"\n",__FILE__,__LINE__,getString(l_Tree));
						// Value is Not computable
						if(p_Value->isBoolComputable()==0)
						{
							l_Result=new value(p_Value->getTree());
							l_Result->setUnComputable();
						}
					}
				}
				break;

				case Node_Ada_C_Integer:
				l_Result->setNumValue(l_Tree->getInteger());
				break;

				// x < y
				case Node_Ada_C_Less:
				{
					value l_LeftMemberValue(l_Tree->getSon(0));
					value l_RightMemberValue(l_Tree->getSon(1));
					l_LeftMemberValue = *calculate( p_FpLog, &l_LeftMemberValue, p_MainUnit);
					l_RightMemberValue = *calculate( p_FpLog, &l_RightMemberValue, p_MainUnit);
					if(l_LeftMemberValue.isBoolComputed()==0 || l_RightMemberValue.isBoolComputed()==0)
					{
						l_Result = l_Result->setUnComputable();
					}
					else
					{	
						l_Result = l_Result->setNumValue( l_LeftMemberValue.getNumValue() < l_RightMemberValue.getNumValue());
					}
				}
				break;
				
				// x <= y
				case Node_Ada_C_Less_Equal:
				{
					value l_LeftMemberValue(l_Tree->getSon(0));
					value l_RightMemberValue(l_Tree->getSon(1));
					l_LeftMemberValue = *calculate( p_FpLog, &l_LeftMemberValue, p_MainUnit);
					l_RightMemberValue = *calculate( p_FpLog, &l_RightMemberValue, p_MainUnit);
					if(l_LeftMemberValue.isBoolComputed()==0 || l_RightMemberValue.isBoolComputed()==0)
					{
						l_Result = l_Result->setUnComputable();
					}
					else
					{	
						l_Result = l_Result->setNumValue( l_LeftMemberValue.getNumValue() <= l_RightMemberValue.getNumValue());
					}
				}
				break;

				// x - y
				case Node_Ada_C_Minor:
				{
					value l_LeftMemberValue(l_Tree->getSon(0));
					value l_RightMemberValue(l_Tree->getSon(1));
					l_LeftMemberValue = *calculate( p_FpLog, &l_LeftMemberValue, p_MainUnit);
					l_RightMemberValue = *calculate( p_FpLog, &l_RightMemberValue, p_MainUnit);
					if(l_LeftMemberValue.isBoolComputed()==0 || l_RightMemberValue.isBoolComputed()==0)
					{
						l_Result = l_Result->setUnComputable();
					}
					else
					{	
						l_Result = l_Result->setNumValue( l_LeftMemberValue.getNumValue() - l_RightMemberValue.getNumValue());
					}
				}
				break;
				
				// x mod y
				case Node_Ada_Mod:
				{
					value l_LeftMemberValue(l_Tree->getSon(0));
					value l_RightMemberValue(l_Tree->getSon(1));
					l_LeftMemberValue=*calculate(p_FpLog,&l_LeftMemberValue,p_MainUnit);
					l_RightMemberValue=*calculate(p_FpLog,&l_RightMemberValue,p_MainUnit);
					if(l_LeftMemberValue.isBoolComputed()==0 || l_RightMemberValue.isBoolComputed()==0)
					{
						l_Result = l_Result->setUnComputable();
					}
					else
					{	
						double l_X=l_LeftMemberValue.getNumValue();
						double l_Y=l_RightMemberValue.getNumValue();
						l_Result=l_Result->setNumValue(l_X-l_Y*floor(l_X/l_Y));
					}
				}
				break;
				
				// x * y
				case Node_Ada_C_Mult:
				{
					value l_LeftMemberValue(l_Tree->getSon(0));
					value l_RightMemberValue(l_Tree->getSon(1));
					l_LeftMemberValue = *calculate( p_FpLog, &l_LeftMemberValue, p_MainUnit);
					l_RightMemberValue = *calculate( p_FpLog, &l_RightMemberValue, p_MainUnit);
					if(l_LeftMemberValue.isBoolComputed()==0 || l_RightMemberValue.isBoolComputed()==0)
					{
						l_Result = l_Result->setUnComputable();
					}
					else
					{	
						l_Result = l_Result->setNumValue( l_LeftMemberValue.getNumValue() * l_RightMemberValue.getNumValue());
					}

					
					
				}
				break;
				
				// x != y
				case Node_Ada_Non_Equal:
				{
					value l_LeftMemberValue(l_Tree->getSon(0));
					value l_RightMemberValue(l_Tree->getSon(1));
					l_LeftMemberValue = *calculate( p_FpLog, &l_LeftMemberValue, p_MainUnit);
					l_RightMemberValue = *calculate( p_FpLog, &l_RightMemberValue, p_MainUnit);
					if(l_LeftMemberValue.isBoolComputed()==0 || l_RightMemberValue.isBoolComputed()==0)
					{
						l_Result = l_Result->setUnComputable();
					}
					else
					{	
						l_Result = l_Result->setNumValue( l_LeftMemberValue.getNumValue() != l_RightMemberValue.getNumValue());
					}
				}
				break;
				
				// ! x 
				case Node_Ada_Not:
				{
					value l_LeftMemberValue(l_Tree->getSon(0));
					l_LeftMemberValue = *calculate( p_FpLog, &l_LeftMemberValue, p_MainUnit);
					if(l_LeftMemberValue.isBoolComputed()==0)
					{
						l_Result = l_Result->setUnComputable();
					}
					else
					{	
						l_Result = l_Result->setNumValue(!(l_LeftMemberValue.getNumValue()));
					}
				}
				break;
				
				// x | y
				case Node_Ada_Or_Else:
				case Node_Ada_Or:
				{
					value l_LeftMemberValue(l_Tree->getSon(0));
					value l_RightMemberValue(l_Tree->getSon(1));
					l_LeftMemberValue = *calculate( p_FpLog, &l_LeftMemberValue, p_MainUnit);
					l_RightMemberValue = *calculate( p_FpLog, &l_RightMemberValue, p_MainUnit);
					if(l_LeftMemberValue.isBoolComputed()==0 || l_RightMemberValue.isBoolComputed()==0)
					{
						l_Result = l_Result->setUnComputable();
					}
					else
					{	
						l_Result = l_Result->setNumValue( ((int)l_LeftMemberValue.getNumValue()) | ((int)l_RightMemberValue.getNumValue()));
					}
				}
				break;
				
				// ( x )
				case Node_Ada_C_Parenthesized_Primary:
				{
					value l_LeftMemberValue(l_Tree->getSon(0));
					l_LeftMemberValue = *calculate( p_FpLog, &l_LeftMemberValue, p_MainUnit);
					if(l_LeftMemberValue.isBoolComputed()==0)
					{
						l_Result = l_Result->setUnComputable();
					}
					else
					{	
						l_Result = l_Result->setNumValue(l_LeftMemberValue.getNumValue());
					}
				}
				break;
				
				
				// x + y
				case Node_Ada_C_Plus:
				{
					value l_LeftMemberValue(l_Tree->getSon(0));
					value l_RightMemberValue(l_Tree->getSon(1));
					l_LeftMemberValue=*calculate(p_FpLog,&l_LeftMemberValue,p_MainUnit);
					l_RightMemberValue=*calculate(p_FpLog,&l_RightMemberValue,p_MainUnit);
					if(l_LeftMemberValue.isBoolComputed()==0 || l_RightMemberValue.isBoolComputed()==0)
					{
						l_Result = l_Result->setUnComputable();
					}
					else
					{	
						l_Result=l_Result->setNumValue(l_LeftMemberValue.getNumValue() + l_RightMemberValue.getNumValue());
					}
				}
				break;

				// pow(x, y)
				case Node_Ada_Power:
				{
					value l_LeftMemberValue(l_Tree->getSon(0));
					value l_RightMemberValue(l_Tree->getSon(1));
					l_LeftMemberValue=*calculate(p_FpLog,&l_LeftMemberValue,p_MainUnit);
					l_RightMemberValue=*calculate(p_FpLog,&l_RightMemberValue,p_MainUnit);
					if(l_LeftMemberValue.isBoolComputed()==0 || l_RightMemberValue.isBoolComputed()==0)
					{
						l_Result = l_Result->setUnComputable();
					}
					else
					{	
						l_Result=l_Result->setNumValue(pow(l_LeftMemberValue.getNumValue(),l_RightMemberValue.getNumValue()));
					}
				}
				break;

				// x rem y
				case Node_Ada_Rem:
				{
					value l_LeftMemberValue(l_Tree->getSon(0));
					value l_RightMemberValue(l_Tree->getSon(1));
					l_LeftMemberValue=*calculate(p_FpLog,&l_LeftMemberValue,p_MainUnit);
					l_RightMemberValue=*calculate(p_FpLog,&l_RightMemberValue,p_MainUnit);
					if(l_LeftMemberValue.isBoolComputed()==0 || l_RightMemberValue.isBoolComputed()==0)
					{
						l_Result = l_Result->setUnComputable();
					}
					else
					{	
						double l_X=l_LeftMemberValue.getNumValue();
						double l_Y=l_RightMemberValue.getNumValue();
						
						if(l_X*l_Y>0)
						{
							l_Result=l_Result->setNumValue(l_X-l_Y*floor(l_X/l_Y));
						}
						else
						{
							l_Result=l_Result->setNumValue(l_X-l_Y*ceil(l_X/l_Y));
						}
					}
				}
				break;
				
				case Node_Ada_Selected_Comp:
				{
					package_spec *l_PackageSpec=NULL;
					if( (l_PackageSpec = getPackageSpec( p_FpLog, getString( l_Tree->getSon(0) ), p_MainUnit)) == NULL)
					{
						// TO_COMPLETE
						
					}
					else
					{
						
						// Search of variable whose name is represented by son 1 in package whose name is given by son 0
						//printf("%s %i : searchOfVariable \"%s\" in package \"%s\"\n",__FILE__,__LINE__,getString( l_Tree->getSon(1) ), getString( l_Tree->getSon(0) ));
						variable *l_Variable=searchVariable(p_FpLog,getString( l_Tree->getSon(1) ),l_PackageSpec);

						// Variable found
						if(l_Variable!=NULL)
						{
							//printf("%s %i : variable %s found\n",__FILE__,__LINE__,l_Variable->getName());
							l_Result=calculate(p_FpLog,l_Variable->getInitValue(),p_MainUnit);
						}
						
						// Variable not found
						if(l_Variable==NULL)
						{
							constant_number *l_ConstantNumber=NULL;
							
							// Search of constant number
							if((l_ConstantNumber=searchConstantNumber(p_FpLog,getString( l_Tree->getSon(1) ),l_PackageSpec))!=NULL)
							{
								//printf("%s %i : constant_number %s found\n",__FILE__,__LINE__,l_ConstantNumber->getName());
								l_Result=calculate(p_FpLog,l_ConstantNumber->getInitValue(),p_MainUnit);
							}
						}
						
					}
					if(l_Result==NULL)
					{
						printf("%s %i : unable to compute numeric value of \"%s\"\n",__FILE__,__LINE__,getString(l_Tree));
						// Value is Not computable
						if(p_Value->isBoolComputable()==0)
						{
							l_Result=new value(p_Value->getTree());
							l_Result->setUnComputable();
						}
					}	
				}
				break;
				
				// x > y
				case Node_Ada_C_Sup:
				{
					value l_LeftMemberValue(l_Tree->getSon(0));
					value l_RightMemberValue(l_Tree->getSon(1));
					l_LeftMemberValue = *calculate( p_FpLog, &l_LeftMemberValue, p_MainUnit);
					l_RightMemberValue = *calculate( p_FpLog, &l_RightMemberValue, p_MainUnit);
					if(l_LeftMemberValue.isBoolComputed()==0 || l_RightMemberValue.isBoolComputed()==0)
					{
						l_Result = l_Result->setUnComputable();
					}
					else
					{	
						l_Result = l_Result->setNumValue( l_LeftMemberValue.getNumValue() > l_RightMemberValue.getNumValue());
					}
				}
				break;

				// x >= y
				case Node_Ada_C_Sup_Equal:
				{
					value l_LeftMemberValue(l_Tree->getSon(0));
					value l_RightMemberValue(l_Tree->getSon(1));
					l_LeftMemberValue = *calculate( p_FpLog, &l_LeftMemberValue, p_MainUnit);
					l_RightMemberValue = *calculate( p_FpLog, &l_RightMemberValue, p_MainUnit);
					if(l_LeftMemberValue.isBoolComputed()==0 || l_RightMemberValue.isBoolComputed()==0)
					{
						l_Result = l_Result->setUnComputable();
					}
					else
					{	
						l_Result = l_Result->setNumValue( l_LeftMemberValue.getNumValue() >= l_RightMemberValue.getNumValue());
					}
				}
				break;
				
				// - x
				case Node_Ada_C_Unary_Minor:
				{
					value l_LeftMemberValue(l_Tree->getSon(0));
					l_LeftMemberValue = *calculate( p_FpLog, &l_LeftMemberValue, p_MainUnit);
					if(l_LeftMemberValue.isBoolComputed()==0)
					{
						l_Result = l_Result->setUnComputable();
					}
					else
					{	
						l_Result=l_Result->setNumValue(-l_LeftMemberValue.getNumValue());
					}
				}
				break;
				
				// + y
				case Node_Ada_C_Unary_Plus:
				{
					value l_LeftMemberValue(l_Tree->getSon(0));
					l_LeftMemberValue = *calculate( p_FpLog, &l_LeftMemberValue, p_MainUnit);
					if(l_LeftMemberValue.isBoolComputed()==0)
					{
						l_Result = l_Result->setUnComputable();
					}
					else
					{	
						l_Result = l_Result->setNumValue(l_LeftMemberValue.getNumValue());
					}
				}
				break;
				
				
				/* Default case */
				default:
				l_Result=new value(p_Value->getTree());
				l_Result->setUnComputable();
					
				//printf("%s %i : ligne %i\n",__FILE__,__LINE__,l_Tree->getNumLine());
				//errorNotAllowed( __FILE__, __LINE__, l_Tree, "calculate");
				//my_exit(-1);
				break;

			}

			//p_Value->setNumValue(l_Result->getNumValue());
		}
		else
		{
			// Value is Not computable
			if(p_Value->isBoolComputable()==0)
			{
				l_Result=new value(p_Value->getTree());
				l_Result->setUnComputable();
			}
		}
	}
	else
	{
		// Determine which parameter failed
		if( p_Value == NULL )
		{
			errorIsNull( __FILE__, __LINE__, "p_Value");
		}

		if( p_MainUnit == NULL )
		{
			errorIsNull( __FILE__, __LINE__, "p_MainUnit");
		}
		my_exit(-1);

	}
	
	#ifdef TRACE
	printfTraceDown( "calculate", __FILE__, __LINE__);
	#endif
	
	return l_Result;
}

/*****************************************************************************
 * Function name : getDirectPackageSpec 
 *
 * Input :	p_FpLog reference on a FILE
 * 		p_Name reference on a string
 * Output : package_spec* - reference on a package_spec
 * Modified variable : none
 * Description : Function which return a reference on the package spec
 * 	designed by parameter P_Name
 *****************************************************************************/
package_spec* getDirectPackageSpec( FILE *p_FpLog, const char *p_Name )
{
	#ifdef TRACE
	printfTraceUp( "getDirectPackageSpec", __FILE__, __LINE__);
	#endif
	package_spec *l_Result = NULL;
	
	/* Check of input parameters */
	if( p_Name != NULL)
	{
		list<package_spec*> *l_PackageSpecList = getByName( p_Name,g_TableSymbol->getPackageSpecs() );
		
		if( l_PackageSpecList != NULL)
		{
			/* a package spec is found */
			/***************************/
			if( l_PackageSpecList->getNbItem()==1)
			{
				l_Result = l_PackageSpecList->getItem();
			}
			else
			{
				printf( "ERROR : %s %i : Ambiguity in search of \"%s\" package spec\n", __FILE__, __LINE__, p_Name );
				my_exit(-1);
			}
		}
	}
	else
	{
		errorIsNull( __FILE__, __LINE__, "p_Name");
		my_exit(-1);
	}
	#ifdef TRACE
	printfTraceDown( "getDirectPackageSpec", __FILE__, __LINE__);
	#endif
	
	return l_Result;
}

/*****************************************************************************
 * Function name : getPackageSpec 
 *
 * Input :	p_FpLog reference on a FILE
 * 		p_Name reference on a string
 * 		p_CurrentMainUnit reference on a main_unit
 * Output : package_spec* - reference on a package_spec
 * Modified variable : none
 * Description : Function which return a reference on package_spec correspondig
 * 	to p_Name by using symbol table and links of p_CurrentMainunit
 *****************************************************************************/ 
package_spec* getPackageSpec( FILE *p_FpLog, const char *p_Name,main_unit *p_CurrentMainUnit )
{
	#ifdef TRACE
	printfTraceUp( "getPackageSpec", __FILE__, __LINE__);
	#endif
	
	package_spec *l_Result = NULL;
	const char *l_Name = p_Name;
	
	/* Check of input parameters */
	if( p_Name != NULL && p_CurrentMainUnit != NULL)
	{
		/* search of a package rename whose new name is p_Name */
		package_rename *l_PackageRename = searchPackageRename( p_FpLog, p_CurrentMainUnit, p_Name );
		
		/* if the package rename was found p_Name become the original name */
		if( l_PackageRename != NULL)
		{
			l_Name=l_PackageRename->getOriginalName();
		}
		
		/* Search of package spec whose name is p_Name */
		l_Result = getDirectPackageSpec( p_FpLog, l_Name );
		
	}
	else
	{
		// Determine which parameter failed
		if( p_Name == NULL)
		{
			errorIsNull( __FILE__, __LINE__, "p_Name");
		}
		if( p_CurrentMainUnit == NULL)
		{
			errorIsNull( __FILE__, __LINE__, "p_CurrentMainUnit");
		}
		
		my_exit(-1);
	}
	
	#ifdef TRACE
	printfTraceDown( "getPackageSpec", __FILE__, __LINE__);
	#endif
	
	return l_Result;
}

/*****************************************************************************
 * Function name : getTypeOf 
 *
 * Input :	p_Tree reference on a tree
 *		p_CurrentMainUnit reference on a main_unit
 * Output : type* - Reference on a type object
 * Modified variable : none
 * Description : Function which determines the type of a node
 *****************************************************************************/
type* getTypeOf( FILE *p_FpLog, tree *p_Tree, main_unit *p_CurrentMainUnit )
{
	#ifdef TRACE
		printfTraceUp( "getTypeOf", __FILE__, __LINE__);
	#endif

	type *l_Result = NULL;
	
	// Check of input parameters
	if( p_Tree != NULL && p_CurrentMainUnit != NULL)
	{
		switch( p_Tree->getNodeType() )
		{
			case Node_Ada_Attribute:
			// TO_COMPLETE
			l_Result = getTypeOf( p_FpLog, p_Tree->getSon(0), p_CurrentMainUnit );
			break;
			case Node_Ada_C_Ident:
			{
				// search variable whose name is represented by node_ident
				variable *l_Variable = searchVariable( p_FpLog, p_Tree->getString(), p_CurrentMainUnit );
				
				//check if variable was found
				if( l_Variable != NULL)
				{
			/*		char *l_TypeName = NULL;
					
					// Search of type name in function of variable type
					switch( l_Variable->getVariableId() )
					{
						case Variable_Object:
							l_TypeName = ( (variable_object* ) l_Variable )->getTypeName();
						break;
						case Variable_Array:
							l_TypeName = ( (variable_array* ) l_Variable )->getTypeName();
						break;
					}
					
					// Search of type by name
					l_Result = searchType( p_FpLog, l_TypeName, l_Variable->getMainUnit() );*/
					
					// Search of type in function of variable type
					switch( l_Variable->getVariableId() )
					{
						case Variable_Object:
							l_Result = searchType(p_FpLog,(variable_object*)l_Variable,l_Variable->getMainUnit() );
						break;
						case Variable_Array:
							l_Result = searchType(p_FpLog,(variable_array*)l_Variable,l_Variable->getMainUnit() );
						break;
					}
				}
			}
			break;
			case Node_Ada_Indexed_Comp:
				// type of son 1 is not important so search of type on son 0
				l_Result = getTypeOf( p_FpLog, p_Tree->getSon(0), p_CurrentMainUnit );
			break;
			case Node_Ada_Selected_Comp:
			{
				// Determine if son 0 is a package spec
				package_spec *l_PackageSpec = getPackageSpec( p_FpLog, getString( p_Tree->getSon(0) ), p_CurrentMainUnit );
				
				// Check if a package spec corresponding to son 0 was found
				if( l_PackageSpec != NULL)
				{
					// A package spec was found so the type of selected comp is type of son 1
					l_Result = getTypeOf( p_FpLog, p_Tree->getSon(1), l_PackageSpec);
				}
				else
				{
					// son 0 is not a package spec so it is a type
					type *l_Type = getTypeOf( p_FpLog, p_Tree->getSon(0), p_CurrentMainUnit );
					
					// Check if type is found
					if( l_Type != NULL)
					{
						// Check if type is a Composite Type
						if( l_Type->getTypeId() == Type_Composite )
						{
							composite_type *l_CompositeType = (composite_type* ) l_Type;
							
							//check if composite type is a record type
							if( l_CompositeType->getCompositeTypeId() == Composite_Type_Record)
							{
								// Recuperation of component list of record type
								component_list *l_ComponentList = ( (record_type* ) l_CompositeType )->getComponentList();
								
								// Search of component whose name is represented by son 1 in component list
								list<component*> *l_Components = getByName( getString( p_Tree->getSon(1) ), l_ComponentList->getComponents() );
								
								// Check if component was found
								if( l_Components != NULL)
								{
									// check if one component was returned
									if( l_Components->getNbItem() == 1)
									{
									/*	// Recuperation of type name of component
										char *l_TypeName = l_Components->getItem()->getTypeName();
										
										// Search of type whose name is l_TypeName
										l_Result = searchType( p_FpLog, l_TypeName, l_CompositeType->getMainUnit() );*/

										l_Result=searchType(p_FpLog,l_Components->getItem(),l_CompositeType->getMainUnit() );
									}
									else
									{
										printf("ERROR : %s %i : ambiguity during search of component \"%s\" of record type \"%s\"\n",__FILE__,__LINE__,l_Type->getName(),getString( p_Tree->getSon(1) ));
										my_exit(-1);
									}
								}
							}
						}
					}
				}
			}
			break;
			case Node_Ada_Selected_Comp_All:
			// TO_COMPLETE
			l_Result = getTypeOf( p_FpLog, p_Tree->getSon(0), p_CurrentMainUnit );
			break;
			default:
			// Unknown node for object_name rule
			errorNotAllowed( __FILE__, __LINE__, p_Tree, "object name");
			my_exit(-1);
			break;
		}
	}
	else
	{
		// Determination of failed parameter
		if( p_Tree == NULL)
		{
			errorIsNull( __FILE__, __LINE__, "p_Tree");
		}
		if( p_CurrentMainUnit == NULL)
		{
			errorIsNull( __FILE__, __LINE__, "p_CurrentMainUnit");
		}
		
		my_exit(-1);
	}
	#ifdef TRACE
	printfTraceDown( "getTypeOf", __FILE__, __LINE__);
	#endif
	
	return l_Result;
}

/*****************************************************************************
* Function name : isAnArray 
*
* Input :	p_FpLog - reference on the log file
*			p_Tree	- reference on a tree
*			p_CurrentMainUnit - reference on a main_unit
* Output : array* - Reference on the array represented by node p_Tree
* Modified variable : none
* Description : Function which determines if a node represents an array.
*	If the node doesn't represent an array, returned value is NULL
*****************************************************************************/
array* isAnArray( FILE *p_FpLog, tree *p_Tree,main_unit *p_CurrentMainUnit)
{
	#ifdef TRACE
		printfTraceUp( "isAnArray", __FILE__, __LINE__);
	#endif
	
	array *l_Result = NULL;
	
	/* Check of input parameters */
	if( p_Tree != NULL && p_CurrentMainUnit != NULL)
	{
		/* Function is defined for Node_Ada_Indexed_Comp so check of node type */
		if( p_Tree->getNodeType() == Node_Ada_Indexed_Comp)
		{
			
			/* Determine the type of son 0 of p_Tree */
			switch( p_Tree->getSon(0)->getNodeType() )
			{
				/* p_Tree->getSon(0) is a Node_Ada_C_Ident */
				/*******************************************/
				case Node_Ada_C_Ident:
				{
					
					/* Search of variable whose name is string contain in Ada_C_Ident node */
					variable *l_Variable = searchVariable( p_FpLog, p_Tree->getSon(0)->getString(), p_CurrentMainUnit );
						
					/* Check if variable was found */
					if( l_Variable != NULL)
					{
						// check if variable is an array variable
						l_Result = isAnArray( p_FpLog, l_Variable );
					}
				}
				break;
				
				/* p_Tree->getSon(0) is a Node_Ada_Indexed_Comp */
				/************************************************/
				case Node_Ada_Indexed_Comp:
				{
					// Determine type of node indexed_comp
					type *l_Type = getTypeOf( p_FpLog, p_Tree->getSon(0), p_CurrentMainUnit );

					// check if type was determined
					if( l_Type != NULL)
					{
						// Check if type is an array type
						l_Result = isAnArray( p_FpLog, l_Type );
					}
				}
				break;
				
				/* p_Tree->getSon(0) is a Node_Ada_Selected_Comp_All */
				/*****************************************************/
				case Node_Ada_Selected_Comp_All:
					// TO_COMPLETE
				break;
				
				/* p_Tree->getSon(0) is a Node_Ada_Selected_Comp */
				/*************************************************/
				case Node_Ada_Selected_Comp:
				{
					// Search the package specification which could correspond to son 0 of node selected comp
					package_spec *l_PackageSpec = getPackageSpec( p_FpLog, getString( p_Tree->getSon(0)->getSon(0) ), p_CurrentMainUnit );
					
					// Determine if package specification exists
					if( l_PackageSpec != NULL)
					{
						// Package specification exists so search a variable whose name is son 1 of selected comp
						variable *l_Variable = l_PackageSpec->getVariable( getString( p_Tree->getSon(0)->getSon(1) ) );
						
						// Determine if variable was found
						if( l_Variable != NULL)
						{
							// Check if variable is an array
							l_Result = isAnArray( p_FpLog, l_Variable );
						}
						else
						{
							// Node_Ada_C_Ident doesn't represent a variable so it can be a function with no parameters
							function_spec *l_FunctionSpec = searchFunctionSpec(p_FpLog, getString( p_Tree->getSon(0)->getSon(1) ),l_PackageSpec);

							if(l_FunctionSpec!=NULL)
							{
								type *l_Type= searchType(p_FpLog, l_FunctionSpec->getTypeName(), l_FunctionSpec->getMainUnit());
								
								if(l_Type!=NULL)
								{
									l_Result= isAnArray(p_FpLog, l_Type);
								}
								
							}
						}
					}
					else
					{
						// Son 0 of selected comp is not a package specification so it could be a composite type
						// Determination of type of son 0
						type *l_Type = getTypeOf( p_FpLog, p_Tree->getSon(0), p_CurrentMainUnit );
						
						//Check if type was found
						if( l_Type != NULL)
						{
							// Check if variable is an array
							l_Result = isAnArray( p_FpLog, l_Type );
						}
					}
				}
				break;
			}
		}
		else
		{
			// Node type is not an Indexed_comp"
			errorNotAllowed( __FILE__, __LINE__, p_Tree, "indexed_comp");
			my_exit(-1);
		}
	}
	else
	{
		// Determine which parameter failed
		if( p_Tree == NULL)
		{
			errorIsNull( __FILE__, __LINE__, "p_Tree");
		}
		
		if( p_CurrentMainUnit == NULL)
		{
			errorIsNull( __FILE__, __LINE__, "p_CurrentMainUnit");
		}
		
		my_exit(-1);
	}
	#ifdef TRACE
		printfTraceDown( "isAnArray", __FILE__, __LINE__);
	#endif
	return l_Result;
}

/*****************************************************************************
 * Function name : isAnArray 
 *
 * Input :	p_FpLog reference on a FILE
 * 		p_Type reference on a type
 * Output : array* - reference on an array
 * Modified variable : none
 * Description : Function which return a reference on the array corresponding
 * 	to p_Type
 * 	NULL is returned if p_Type is not an array type
 *****************************************************************************/ 
array* isAnArray( FILE *p_FpLog, type *p_Type )
{
	#ifdef TRACE
	printfTraceUp( "isAnArray", __FILE__, __LINE__);
	#endif
	array *l_Result = NULL;
	
	/* Check of input parameters */
	if( p_Type != NULL)
	{
		switch( p_Type->getTypeId() )
		{
			/* Composite Type : type is an array type only if it composite type array */
			case Type_Composite:
			{
				composite_type *l_CompositeType = (composite_type* ) p_Type;
				
				if( l_CompositeType->getCompositeTypeId() == Composite_Type_Array)
				{
					l_Result = ( array* ) l_CompositeType;
				}
			}
			break;
			/* Derived type : type is an array only if its parent type is an array type */
			case Type_Derived:
			{
				// get name of origin type
				/*char *l_TypeName = ( ( derived_type* ) p_Type )->getTypeName();
				if( l_TypeName == NULL)
				{
					errorIsNull( __FILE__, __LINE__, "l_TypeName");
					my_exit(-1);
				}
				
				// get origin type
				type *l_Type = searchType( p_FpLog, l_TypeName, p_Type->getMainUnit() );*/

				type *l_Type=searchType(p_FpLog,( derived_type* ) p_Type,p_Type->getMainUnit() );

				if( l_Type != NULL)
				{
					l_Result=isAnArray( p_FpLog, l_Type );
				}
				
			}
			break;
			/* Elementary type : type is an array type only if it's an access type on array type */
        	case Type_Elementary:
			{
				elementary_type *l_Elementary_Type = (elementary_type* ) p_Type;
				if( l_Elementary_Type->getElementaryTypeId() == Elementary_Type_Access )
				{
					access_type *l_AccessType = ( access_type* ) l_Elementary_Type;
					if( l_AccessType->getAccessTypeId() == Access_Type_Object )
					{
						/*char *l_TypeName = ( ( access_object_type* ) l_AccessType )->getTypeName();
						if( l_TypeName == NULL)
						{
							errorIsNull( __FILE__, __LINE__, "l_TypeName");
							my_exit(-1);
						}

						// get origin type
						type *l_Type = searchType( p_FpLog, l_TypeName, p_Type->getMainUnit() );*/

						type *l_Type=searchType(p_FpLog,( access_object_type* ) p_Type,p_Type->getMainUnit() );

						if( l_Type != NULL)
						{
							l_Result=isAnArray( p_FpLog, l_Type );
						}
					}
				}
			}
			break;
			
        		/* Subtype type : type is an array only if its parent type is an array type */
			case Type_Subtype:
			{
				/*char *l_TypeName = ( (subtype* ) p_Type )->getTypeName();
				if( l_TypeName == NULL)
				{
					errorIsNull( __FILE__, __LINE__, "l_TypeName");
					my_exit(-1);
				}

				// get origin type
				type *l_Type = searchType( p_FpLog, l_TypeName, p_Type->getMainUnit() );*/

				type *l_Type=searchType(p_FpLog,( subtype* ) p_Type,p_Type->getMainUnit() );

				if( l_Type != NULL)
				{
					l_Result=isAnArray( p_FpLog, l_Type );
				}
			}
			break;
			/* Default case */
			default:
			errorNotManage( __FILE__, __LINE__, p_Type->getTypeId() );
			my_exit(-1);
			break;

		}
	}
	else
	{
		errorIsNull( __FILE__, __LINE__, "p_Type");
		my_exit(-1);
	}
	#ifdef TRACE
	printfTraceDown( "isAnArray", __FILE__, __LINE__);
	#endif
	return l_Result;
}

/*****************************************************************************
 * Function name : isAnArray 
 *
 * Input :	p_FpLog reference on a FILE
 * 		p_Variable reference on a variable
 * Output : array* - reference on an array
 * Modified variable : none
 * Description : Function which return a reference on the array corresponding
 * 	to variable referenced by p_Variable
 *****************************************************************************/ 
array* isAnArray( FILE *p_FpLog, variable *p_Variable )
{
	#ifdef TRACE
	printfTraceUp( "isAnArray", __FILE__, __LINE__);
	#endif
	array *l_Result = NULL;
	
	/* Check of input parameters */
	if( p_Variable != NULL)
	{
		switch( p_Variable->getVariableId() )
		{
			// the variable is a variable array
			case Variable_Array:
			l_Result = ( array* ) p_Variable;
			break;
			// the variable is an object
			case Variable_Object:
			{
				/*char *l_TypeName = ( (variable_object* ) p_Variable )->getTypeName();
					
				type *l_Type = searchType( p_FpLog, l_TypeName, p_Variable->getMainUnit() );*/
				
				type *l_Type = searchType( p_FpLog, (variable_object* ) p_Variable, p_Variable->getMainUnit() );


				if( l_Type != NULL)
				{
					l_Result=isAnArray( p_FpLog, l_Type );
				}
				
			}
			break;
		}
	}
	else
	{
		errorIsNull( __FILE__, __LINE__, "p_Variable");
		my_exit(-1);
	}
	#ifdef TRACE
	printfTraceDown( "isAnArray", __FILE__, __LINE__);
	#endif
	return l_Result;
	
}

/*****************************************************************************
* Function name : isTypeAnArray 
*
* Input :	p_FpLog - reference on the log file
*			p_Tree	- reference on a tree
*			p_CurrentMainUnit - reference on a main_unit
* Output : array* - Reference on the array represented by node p_Tree
* Modified variable : none
* Description : Function which determines if a node represents an array type.
*	If the node doesn't represent an array type, returned value is NULL
*****************************************************************************/
array* isTypeAnArray( FILE *p_FpLog, tree *p_Tree, main_unit *p_CurrentMainUnit)
{
	#ifdef TRACE
	printfTraceUp( "isTypeAnArray", __FILE__, __LINE__);
	#endif
	array *l_Result = NULL;
	
	/* Check of input parameters */
	if( p_Tree != NULL && p_CurrentMainUnit!=NULL)
	{
		type *l_Type = searchType(p_FpLog,p_Tree,p_CurrentMainUnit);
		if(l_Type!=NULL)
		{
			l_Result=isAnArray(p_FpLog,l_Type);
		}
	}
	else
	{
		// Determine which parameter failed
		if( p_Tree == NULL)
		{
			errorIsNull( __FILE__, __LINE__, "p_Tree");
		}
		if( p_CurrentMainUnit == NULL)
		{
			errorIsNull( __FILE__, __LINE__, "p_CurrentMainUnit");
		}
		my_exit(-1);
	}
	#ifdef TRACE
	printfTraceDown( "isTypeAnArray", __FILE__, __LINE__);
	#endif
	return l_Result;
}

/*****************************************************************************
* Function name : isFunction 
*
* Input :	p_FpLog - reference on the log file
*			p_Tree	- reference on a tree
*			p_CurrentMainUnit - reference on a main_unit
* Output : function_spec* - Reference on the function_spec represented by node p_Tree
* Modified variable : none
* Description : Function which determines if a node represents a function call.
*	If the node doesn't represent a function call, returned value is NULL
*****************************************************************************/
function_spec* isFunction(FILE *p_FpLog, tree *p_Tree, main_unit *p_CurrentMainUnit)
{
	#ifdef TRACE
	printfTraceUp( "isFunction", __FILE__, __LINE__);
	#endif

	function_spec* l_Result = NULL;

	#ifdef TRACE
	printfTraceDown( "isFunction", __FILE__, __LINE__);
	#endif

	return l_Result;

}

/*****************************************************************************
 * Function name : searchConstantNumber 
 *
 * Input :	p_FpLog reference on a FILE
 * 		p_Name reference on a string
 * 		p_CurrentMainUnit - reference on a main_unit
 * Output : constant_number* - reference on a constant_number
 * Modified variable : none
 * Description : Function which return a reference on the constant_number whose
 * 	name is p_Name
 * 	NULL is returned if p_Name is not the name of a constant_number
 *****************************************************************************/ 
constant_number* searchConstantNumber( FILE *p_FpLog, const char *p_Name,main_unit *p_CurrentMainUnit )
{
	#ifdef TRACE
	printfTraceUp( "searchConstantNumber", __FILE__, __LINE__);
	#endif
	
	constant_number *l_Result = NULL;
	
	/* Check of input parameters */
	if( p_Name != NULL && p_CurrentMainUnit != NULL)
	{
		// Search in file containing p_CurrentMainunit
		l_Result = p_CurrentMainUnit->getConstantNumber( p_Name );
		
		if( l_Result == NULL)
		{
			package *l_Package = p_CurrentMainUnit->getPackage();
			if( l_Package != NULL)
			{
				package_spec *l_PackageSpec = getDirectPackageSpec( p_FpLog, l_Package->getName() );
				if( l_PackageSpec != NULL)
				{
					l_Result = l_PackageSpec->getConstantNumber( p_Name );
				}
			}
		}
		// if variable not found, search in its dependancies
		if( l_Result == NULL)
		{
			l_Result = searchConstantNumberInDependancies( p_FpLog, p_Name, p_CurrentMainUnit );
		}
	}
	else
	{
		// Determine which parameter failed
		if( p_Name == NULL)
		{
			errorIsNull( __FILE__, __LINE__, "p_Name");
		}
		if( p_CurrentMainUnit == NULL)
		{
			errorIsNull( __FILE__, __LINE__, "p_CurrentMainUnit");
		}
		my_exit(-1);
	}
	
	
	#ifdef TRACE
	printfTraceDown( "searchConstantNumber", __FILE__, __LINE__);
	#endif
	return l_Result;
	
}


/*****************************************************************************
 * Function name : searchConstantNumberInDependancies 
 *
 * Input :	p_FpLog reference on a FILE
 * 		p_Name reference on a string
 * 		p_CurrentMainUnit - reference on a main_unit
 * Output : constant_number* - reference on a constant_number
 * Modified variable : none
 * Description : Function which return a reference on the constant_number whose
 * 	name is p_Name
 * 	NULL is returned if p_Name is not the name of a constant_number
 *****************************************************************************/ 
constant_number* searchConstantNumberInDependancies( FILE *p_FpLog, const char *p_Name,main_unit *p_CurrentMainUnit )
{
	#ifdef TRACE
	printfTraceUp( "searchConstantNumberInDependancies", __FILE__, __LINE__);
	#endif
	constant_number *l_Result = NULL;
	
	/* Check of input parameters */
	if( p_Name != NULL && p_CurrentMainUnit != NULL)
	{
		// recuperation of dependancies
		list<named*> *l_ListDependancies = p_CurrentMainUnit->getGlobalWithDependancies();

		// while variable not found search in local dependancies
		list<named*> *l_Current = l_ListDependancies;
		list<package_spec*> *l_PackageSpecs = NULL;
		
		while( l_Result == NULL && l_Current != NULL)
		{
			package_spec *l_PackageSpec = getDirectPackageSpec( p_FpLog, l_Current->getItem()->getName() );
			if( l_PackageSpec != NULL)
			{
				l_PackageSpecs = add( l_PackageSpec, l_PackageSpecs );
				l_Result = l_PackageSpec->getConstantNumber( p_Name );
			}
			l_Current = l_Current->getNext();
		}
		
		// if variable not found in dependancies, serach in dependancies of dependancies
		list<package_spec*> *l_CurrentPackageSpec = l_PackageSpecs;
		
		while( l_Result == NULL && l_CurrentPackageSpec != NULL)
		{
			l_Result = searchConstantNumberInDependancies( p_FpLog, p_Name, l_CurrentPackageSpec->getItem() );
			l_CurrentPackageSpec = l_CurrentPackageSpec->getNext();
		}
		
		
	}
	else
	{
		// Determine which parameter failed
		if( p_Name == NULL)
		{
			errorIsNull( __FILE__, __LINE__, "p_Name");
		}
		if( p_CurrentMainUnit == NULL)
		{
			errorIsNull( __FILE__, __LINE__, "p_CurrentMainUnit");
		}
		my_exit(-1);
	}
	
	
	#ifdef TRACE
	printfTraceDown( "searchConstantNumberInDependancies", __FILE__, __LINE__);
	#endif
	return l_Result;
	
}

/*****************************************************************************
 * Function name : searchFunctionSpec 
 *
 * Input :	p_FpLog reference on a FILE
 * 		p_Name reference on a string
 * 		p_CurrentMainUnit - reference on a main_unit
 * Output : function_spec* - reference on a type
 * Modified variable : none
 * Description : Function which return a reference on the function_spec whose
 * 	name is p_Name
 * 	NULL is returned if p_Name is not the name of a function_spec
 *****************************************************************************/ 
function_spec* searchFunctionSpec( FILE *p_FpLog, const char *p_Name,main_unit *p_CurrentMainUnit )
{
	#ifdef TRACE
	printfTraceUp( "searchFunctionSpec", __FILE__, __LINE__);
	#endif
	
	function_spec *l_Result = NULL;
	
	/* Check of input parameters */
	if( p_Name != NULL && p_CurrentMainUnit != NULL)
	{
		// Search in file containing p_CurrentMainunit
		l_Result = p_CurrentMainUnit->getFunctionSpec( p_Name );
		
		if( l_Result == NULL)
		{
			package *l_Package = p_CurrentMainUnit->getPackage();
			if( l_Package != NULL)
			{
				package_spec *l_PackageSpec = getDirectPackageSpec( p_FpLog, l_Package->getName() );
				if( l_PackageSpec != NULL)
				{
					l_Result = l_PackageSpec->getFunctionSpec( p_Name );
				}
			}
		}
		// if variable not found, search in its dependancies
		if( l_Result == NULL)
		{
			l_Result = searchFunctionSpecInDependancies( p_FpLog, p_Name, p_CurrentMainUnit );
		}
	}
	else
	{
		// Determine which parameter failed
		if( p_Name == NULL)
		{
			errorIsNull( __FILE__, __LINE__, "p_Name");
		}
		if( p_CurrentMainUnit == NULL)
		{
			errorIsNull( __FILE__, __LINE__, "p_CurrentMainUnit");
		}
		my_exit(-1);
	}
	
	
	#ifdef TRACE
	printfTraceDown( "searchFunctionSpec", __FILE__, __LINE__);
	#endif
	return l_Result;
	
}

/*****************************************************************************
 * Function name : searchFunctionSpecInDependancies 
 *
 * Input :	p_FpLog reference on a FILE
 * 		p_Name reference on a string
 * 		p_CurrentMainUnit - reference on a main_unit
 * Output : function_spec* - reference on a type
 * Modified variable : none
 * Description : Function which return a reference on the function_spec whose
 * 	name is p_Name
 * 	NULL is returned if p_Name is not the name of a function_spec
 *****************************************************************************/ 
function_spec* searchFunctionSpecInDependancies( FILE *p_FpLog, const char *p_Name,main_unit *p_CurrentMainUnit )
{
	#ifdef TRACE
	printfTraceUp( "searchFunctionSpecInDependancies", __FILE__, __LINE__);
	#endif
	function_spec *l_Result = NULL;
	
	/* Check of input parameters */
	if( p_Name != NULL && p_CurrentMainUnit != NULL)
	{
		// recuperation of dependancies
		list<named*> *l_ListDependancies = p_CurrentMainUnit->getGlobalWithDependancies();

		// while variable not found search in local dependancies
		list<named*> *l_Current = l_ListDependancies;
		list<package_spec*> *l_PackageSpecs = NULL;
		
		while( l_Result == NULL && l_Current != NULL)
		{
			package_spec *l_PackageSpec = getDirectPackageSpec( p_FpLog, l_Current->getItem()->getName() );
			if( l_PackageSpec != NULL)
			{
				l_PackageSpecs = add( l_PackageSpec, l_PackageSpecs );
				l_Result = l_PackageSpec->getFunctionSpec( p_Name );
			}
			l_Current = l_Current->getNext();
		}
		
		// if variable not found in dependancies, serach in dependancies of dependancies
		list<package_spec*> *l_CurrentPackageSpec = l_PackageSpecs;
		
		while( l_Result == NULL && l_CurrentPackageSpec != NULL)
		{
			l_Result = searchFunctionSpecInDependancies( p_FpLog, p_Name, l_CurrentPackageSpec->getItem() );
			l_CurrentPackageSpec = l_CurrentPackageSpec->getNext();
		}
		
		
	}
	else
	{
		// Determine which parameter failed
		if( p_Name == NULL)
		{
			errorIsNull( __FILE__, __LINE__, "p_Name");
		}
		if( p_CurrentMainUnit == NULL)
		{
			errorIsNull( __FILE__, __LINE__, "p_CurrentMainUnit");
		}
		my_exit(-1);
	}
	
	
	#ifdef TRACE
	printfTraceDown( "searchFunctionSpecInDependancies", __FILE__, __LINE__);
	#endif
	return l_Result;
	
}

/*****************************************************************************
 * Function name : searchPackageRename 
 *
 * Input :	p_FpLog reference on a FILE
 * 		p_Name reference on a string
 * 		p_MainUnit reference on a main_unit
 * Output : package_rename* - reference on a package_rename
 * Modified variable : none
 * Description : Function which return a reference on a package rename 
 * 	corresponding to p_Name
 *****************************************************************************/ 
package_rename* searchPackageRename( FILE *p_FpLog, main_unit *p_MainUnit,const char *p_Name )
{
	#ifdef TRACE
	printfTraceUp( "searchPackageRename", __FILE__, __LINE__);
	#endif
	package_rename *l_Result = NULL;
	
	/* Check of input parameters */
	if( p_MainUnit != NULL && p_Name != NULL)
	{
		/* Search of package renames */
		/*****************************/
		l_Result = p_MainUnit->getPackageRename( p_Name );

		if( l_Result == NULL)
		{
			/* No package rename found in current file */
			/*******************************************/
			if( p_MainUnit->getMainUnitType()==Main_Unit_Package )
			{
				if( ( ( package* ) p_MainUnit )->getPackageType() == Body)
				{
					/* p_MainUnit is a package body so package rename is search in corresponding package spec */
					/******************************************************************************************/
					list<package_spec*> *l_PackageSpecList = getByName( p_MainUnit->getName(),g_TableSymbol->getPackageSpecs() );
					if( l_PackageSpecList != NULL)
					{
						/* a package spec is found */
						/***************************/
						if( l_PackageSpecList->getNbItem()==1)
						{
							l_Result = l_PackageSpecList->getItem()->getPackageRename( p_Name );
						}
						else
						{
							printf( "ERROR : %s %i : Ambiguity in search of \"%s\" package spec\n", __FILE__, __LINE__, p_MainUnit->getName() );
							my_exit(-1);
						}
					}
				}
			}
			else
			{
				package *l_Package = p_MainUnit->getPackage();
				
				if( l_Package != NULL)
				{
					if( l_Package->getPackageType() == Body)
					{
						/* p_MainUnit is a package body so package rename is search in corresponding package spec */
						/******************************************************************************************/
						list<package_spec*> *l_PackageSpecList = getByName( l_Package->getName(),g_TableSymbol->getPackageSpecs() );
						if( l_PackageSpecList != NULL)
						{
							/* a package spec is found */
							/***************************/
							if( l_PackageSpecList->getNbItem()==1)
							{
								l_Result = l_PackageSpecList->getItem()->getPackageRename( p_Name );
							}
							else
							{
								printf( "ERROR : %s %i : Ambiguity in search of \"%s\" package spec\n", __FILE__, __LINE__, l_Package->getName() );
								my_exit(-1);
							}
						}
					}
				}
				
			}
		}
	}
	else
	{
		// Determine which parameter failed
		if( p_MainUnit == NULL)
		{
			errorIsNull( __FILE__, __LINE__, "p_MainUnit");
		}
		
		if( p_Name == NULL)
		{
			errorIsNull( __FILE__, __LINE__, "p_Name");
		}
		
		my_exit(-1);
	}
	#ifdef TRACE
	printfTraceDown( "searchPackageRename", __FILE__, __LINE__);
	#endif
	
	return l_Result;
}

/*****************************************************************************
 * Function name : searchVariable 
 *
 * Input :	p_FpLog reference on a FILE
 * 		p_Name reference on a string
 * 		p_CurrentMainUnit - reference on a main_unit
 * Output : variable* - reference on an array
 * Modified variable : none
 * Description : Function which return a reference on the variable corresponding
 * 	to p_Name
 *****************************************************************************/ 
variable* searchVariable( FILE *p_FpLog, const char *p_Name,main_unit *p_CurrentMainUnit )
{
	#ifdef TRACE
	printfTraceUp( "searchVariable", __FILE__, __LINE__);
	#endif
	variable *l_Result = NULL;
	
	/* Check of input parameters */
	if( p_Name != NULL && p_CurrentMainUnit != NULL)
	{

		
		if( p_CurrentMainUnit->getMainUnitType()==Main_Unit_Function_Body)
		{
			list<parameter*> *l_Parameters = (static_cast<function_body*>(p_CurrentMainUnit))->getParameters();

			list<parameter*> *l_ParametersResult=getByName(p_Name, l_Parameters);

			if(l_ParametersResult !=NULL)
			{
				l_Result = l_ParametersResult->getItem();
			}
		}
		if( p_CurrentMainUnit->getMainUnitType()==Main_Unit_Procedure_Body)
		{
			list<parameter*> *l_Parameters = (static_cast<procedure_body*>(p_CurrentMainUnit))->getParameters();

			list<parameter*> *l_ParametersResult=getByName(p_Name, l_Parameters);

			if(l_ParametersResult !=NULL)
			{
				l_Result = l_ParametersResult->getItem();
			}
		}

		if( l_Result == NULL)
		{
			/* Search in file containing p_CurrentMainunit */
			l_Result = p_CurrentMainUnit->getVariable( p_Name );
		}

		if( l_Result == NULL)
		{
			package *l_Package = p_CurrentMainUnit->getPackage();
			if( l_Package != NULL)
			{
				package_spec *l_PackageSpec = getDirectPackageSpec( p_FpLog, l_Package->getName() );
				if( l_PackageSpec != NULL)
				{
					l_Result = l_PackageSpec->getVariable( p_Name );
				}
			}
		}
		/* if variable not found, search in its dependancies */
		if( l_Result == NULL)
		{
			l_Result = searchVariableInDependancies( p_FpLog, p_Name, p_CurrentMainUnit );
		}
	}
	else
	{
		// Determine which parameter failed
		if( p_Name == NULL)
		{
			errorIsNull( __FILE__, __LINE__, "p_Name");
		}
		if( p_CurrentMainUnit == NULL)
		{
			errorIsNull( __FILE__, __LINE__, "p_CurrentMainUnit");
		}
		my_exit(-1);
	}
	
	
	#ifdef TRACE
	printfTraceDown( "searchVariable", __FILE__, __LINE__);
	#endif
	return l_Result;
	
}

/*****************************************************************************
 * Function name : searchVariableInDependancies 
 *
 * Input :	p_FpLog reference on a FILE
 * 		p_Name reference on a string
 * 		p_CurrentMainUnit - reference on a main_unit
 * Output : variable* - reference on an array
 * Modified variable : none
 * Description : Function which return a reference on the variable corresponding
 * 	to p_Name
 *****************************************************************************/ 
variable* searchVariableInDependancies( FILE *p_FpLog, const char *p_Name,main_unit *p_CurrentMainUnit )
{
	#ifdef TRACE
	printfTraceUp( "searchVariableInDependancies", __FILE__, __LINE__);
	#endif
	variable *l_Result = NULL;
	
	/* Check of input parameters */
	if( p_Name != NULL && p_CurrentMainUnit != NULL)
	{
		// recuperation of dependancies
		list<named*> *l_ListDependancies = p_CurrentMainUnit->getGlobalWithDependancies();

		// while variable not found search in local dependancies
		list<named*> *l_Current = l_ListDependancies;
		list<package_spec*> *l_PackageSpecs = NULL;
		
		while( l_Result == NULL && l_Current != NULL)
		{
			package_spec *l_PackageSpec = getDirectPackageSpec( p_FpLog, l_Current->getItem()->getName() );
			if( l_PackageSpec != NULL)
			{
				l_PackageSpecs = add( l_PackageSpec, l_PackageSpecs );
				l_Result = l_PackageSpec->getVariable( p_Name );
			}
			l_Current = l_Current->getNext();
		}
		
		// if variable not found in dependancies, serach in dependancies of dependancies
		list<package_spec*> *l_CurrentPackageSpec = l_PackageSpecs;
		
		while( l_Result == NULL && l_CurrentPackageSpec != NULL)
		{
			l_Result = searchVariableInDependancies( p_FpLog, p_Name, l_CurrentPackageSpec->getItem() );
			l_CurrentPackageSpec = l_CurrentPackageSpec->getNext();
		}
		
		
	}
	else
	{
		// Determine which parameter failed
		if( p_Name == NULL)
		{
			errorIsNull( __FILE__, __LINE__, "p_Name");
		}
		if( p_CurrentMainUnit == NULL)
		{
			errorIsNull( __FILE__, __LINE__, "p_CurrentMainUnit");
		}
		my_exit(-1);
	}
	
	
	#ifdef TRACE
	printfTraceDown( "searchVariableInDependancies", __FILE__, __LINE__);
	#endif
	return l_Result;
	
}

/*****************************************************************************
 * Function name : searchType 
 *
 * Input :	p_FpLog reference on a FILE
 * 		p_Name reference on a string
 * 		p_CurrentMainUnit - reference on a main_unit
 * Output : type* - reference on a type
 * Modified variable : none
 * Description : Function which return a reference on the type whose name is p_Name
 * 	NULL is returned if p_Name is not a type name
 *****************************************************************************/ 
type* searchType( FILE *p_FpLog, const char *p_Name,main_unit *p_CurrentMainUnit )
{
	#ifdef TRACE
	printfTraceUp( "searchType", __FILE__, __LINE__);
	#endif
	type *l_Result = NULL;
	
	/* Check of input parameters */
	if( p_Name != NULL && p_CurrentMainUnit != NULL)
	{
		// Search in file containing p_CurrentMainunit
		l_Result = p_CurrentMainUnit->getType( p_Name );
		
		if( l_Result == NULL)
		{
			package *l_Package = p_CurrentMainUnit->getPackage();
			if( l_Package != NULL)
			{
				package_spec *l_PackageSpec = getDirectPackageSpec( p_FpLog, l_Package->getName() );
				if( l_PackageSpec != NULL)
				{
					l_Result = l_PackageSpec->getType( p_Name );
				}
			}
		}
		// if variable not found, search in its dependancies
		if( l_Result == NULL)
		{
			l_Result = searchTypeInDependancies( p_FpLog, p_Name, p_CurrentMainUnit );
		}
	}
	else
	{
		// Determine which parameter failed
		if( p_Name == NULL)
		{
			errorIsNull( __FILE__, __LINE__, "p_Name");
		}
		if( p_CurrentMainUnit == NULL)
		{
			errorIsNull( __FILE__, __LINE__, "p_CurrentMainUnit");
		}
		my_exit(-1);
	}
	
	
	#ifdef TRACE
	printfTraceDown( "searchType", __FILE__, __LINE__);
	#endif
	return l_Result;
	
}

/*****************************************************************************
 * Function name : searchType 
 *
 * Input :	p_FpLog reference on a FILE
 * 		p_Name reference on a string
 * 		p_CurrentMainUnit - reference on a main_unit
 * Output : type* - reference on a type
 * Modified variable : none
 * Description : Function which return a reference on the type of typed class
 * 	if type was found. In contrary case type is searched grom its tree representation
 *****************************************************************************/ 
type* searchType( FILE *p_FpLog, typed *p_Typed,main_unit *p_CurrentMainUnit )
{
	#ifdef TRACE
	printfTraceUp( "searchType", __FILE__, __LINE__);
	#endif
	type *l_Result = NULL;
	
	/* Check of input parameters */
	if( p_Typed != NULL && p_CurrentMainUnit != NULL)
	{

		if(!p_Typed->isBoolSearched())
		{
			
			type *l_Type = searchType(p_FpLog,p_Typed->getTypeTree(),p_CurrentMainUnit);
			
			if(l_Type!=NULL)
			{
				p_Typed->setTypeFound(l_Type);
			}
			else
			{
				p_Typed->setTypeNotFound();
			
			}
		}
			
		if(p_Typed->isBoolFound())
		{
			l_Result=p_Typed->getType();
		}
	}
	else
	{
		// Determine which parameter failed
		if( p_Typed == NULL)
		{
			errorIsNull( __FILE__, __LINE__, "p_Typed");
		}
		if( p_CurrentMainUnit == NULL)
		{
			errorIsNull( __FILE__, __LINE__, "p_CurrentMainUnit");
		}
		my_exit(-1);
	}
	
	
	#ifdef TRACE
	printfTraceDown( "searchType", __FILE__, __LINE__);
	#endif
	return l_Result;
	
}

/*****************************************************************************
* Function name : searchType 
*
* Input :	p_FpLog - reference on the log file
*			p_Tree	- reference on a tree
*			p_CurrentMainUnit - reference on a main_unit
* Output : type* - Reference on the type represented by node p_Tree
* Modified variable : none
* Description : Function which determines if a node represents a type
*	If the node doesn't represent a type returned value is NULL
*****************************************************************************/
type* searchType( FILE *p_FpLog, tree *p_Tree, main_unit *p_CurrentMainUnit)
{
	#ifdef TRACE
	printfTraceUp( "searchType", __FILE__, __LINE__);
	#endif
	type *l_Result=NULL;
	/* Check of input parameters */
	if( p_Tree != NULL && p_CurrentMainUnit != NULL )
	{
		switch(p_Tree->getNodeType())
		{
			case Node_Ada_C_Ident:
				l_Result=searchType(p_FpLog,p_Tree->getString(),p_CurrentMainUnit);
			break;
			case Node_Ada_Mark_Quote:
			case Node_Ada_Indexed_Comp:
				l_Result=searchType(p_FpLog,p_Tree->getSon(0),p_CurrentMainUnit);
			break;
			case Node_Ada_Mark_Point:
			case Node_Ada_Selected_Comp:
			{
				package_spec *l_PackageSpec=getPackageSpec(p_FpLog,getString(p_Tree->getSon(0)),p_CurrentMainUnit);
				if(l_PackageSpec!=NULL)
				{
					l_Result=searchType(p_FpLog,getString(p_Tree->getSon(1)),l_PackageSpec);
				}
			}
			break;
			default:
			errorNotAllowed(__FILE__,__LINE__,p_Tree,"searchType");
			my_exit(-1);
		}
	}
	else
	{
		// Determine which parameter failed
		if( p_Tree == NULL )
		{
			errorIsNull( __FILE__, __LINE__, "p_Tree");
		}

		if( p_CurrentMainUnit == NULL )
		{
			errorIsNull( __FILE__, __LINE__, "p_CurrentMainUnit");
		}
		my_exit(-1);

	}

	#ifdef TRACE
	printfTraceDown( "searchType", __FILE__, __LINE__);
	#endif
	return l_Result;
}


/*****************************************************************************
 * Function name : searchTypeInDependancies 
 *
 * Input :	p_FpLog reference on a FILE
 * 		p_Name reference on a string
 * 		p_CurrentMainUnit - reference on a main_unit
 * Output : type* - reference on a type
 * Modified variable : none
 * Description : Function which return a reference on the type whose name is p_Name
 * 	NULL is returned if p_Name is not a type name
 *****************************************************************************/ 
type* searchTypeInDependancies( FILE *p_FpLog, const char *p_Name,main_unit *p_CurrentMainUnit )
{
	#ifdef TRACE
	printfTraceUp( "searchTypeInDependancies", __FILE__, __LINE__);
	#endif
	type *l_Result = NULL;
	
	/* Check of input parameters */
	if( p_Name != NULL && p_CurrentMainUnit != NULL)
	{
		// recuperation of dependancies
		list<named*> *l_ListDependancies = p_CurrentMainUnit->getGlobalWithDependancies();

		// while variable not found search in local dependancies
		list<named*> *l_Current = l_ListDependancies;
		list<package_spec*> *l_PackageSpecs = NULL;
		
		while( l_Result == NULL && l_Current != NULL)
		{
			package_spec *l_PackageSpec = getDirectPackageSpec( p_FpLog, l_Current->getItem()->getName() );
			if( l_PackageSpec != NULL)
			{
				l_PackageSpecs = add( l_PackageSpec, l_PackageSpecs );
				l_Result = l_PackageSpec->getType( p_Name );
			}
			l_Current = l_Current->getNext();
		}
		
		// if variable not found in dependancies, serach in dependancies of dependancies
		list<package_spec*> *l_CurrentPackageSpec = l_PackageSpecs;
		
		while( l_Result == NULL && l_CurrentPackageSpec != NULL)
		{
			l_Result = searchTypeInDependancies( p_FpLog, p_Name, l_CurrentPackageSpec->getItem() );
			l_CurrentPackageSpec = l_CurrentPackageSpec->getNext();
		}
		
		
	}
	else
	{
		// Determine which parameter failed
		if( p_Name == NULL)
		{
			errorIsNull( __FILE__, __LINE__, "p_Name");
		}
		if( p_CurrentMainUnit == NULL)
		{
			errorIsNull( __FILE__, __LINE__, "p_CurrentMainUnit");
		}
		my_exit(-1);
	}
	
	
	#ifdef TRACE
		printfTraceDown( "searchTypeInDependancies", __FILE__, __LINE__);
	#endif
	return l_Result;
	
}
